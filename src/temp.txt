# Multi-project export for ChatGPT
# Roots:
#   - /cuwacunu/src/include/camahjucunu/exchange
# Date: 2025-10-18 13:09:46 UTC
# Script: parse_context.sh v2.4

## Root: /cuwacunu/src/include/camahjucunu/exchange

===== FILE (skipped non-text): README.md (bytes=0, sha256=e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855) =====

===== FILE: abstract/abstract_mech_account.h (bytes=1403, lines=28, sha256=77f5a622233c2633f56e927ba40228d83c6efc71c4319e866439d542ec17a651) =====
```c
#pragma once
#include "piaabo/dutils.h"
#include "piaabo/darchitecture.h"
#include "camahjucunu/exchange/exchange_utils.h"
#include "camahjucunu/exchange/exchange_types_account.h"
#include "camahjucunu/exchange/exchange_types_enums.h"
#include "camahjucunu/https/curl_toolkit/websockets_api/curl_websocket_api.h"

namespace cuwacunu {
namespace camahjucunu {
namespace exchange {
namespace mech {

/* --- --- --- --- --- --- --- --- --- --- --- */
/*         virtual exchange structure          */
/* --- --- --- --- --- --- --- --- --- --- --- */
struct abstract_mech_account_t {
  virtual std::optional<account_information_ret_t>      account_information      (      account_information_args_t args, bool await = true )  const = 0;
  virtual std::optional<account_order_history_ret_t>    account_order_history    (    account_order_history_args_t args, bool await = true )  const = 0;
  virtual std::optional<account_trade_list_ret_t>       account_trade_list       (       account_trade_list_args_t args, bool await = true )  const = 0;
  virtual std::optional<account_commission_rates_ret_t> account_commission_rates ( account_commission_rates_args_t args, bool await = true )  const = 0;
  virtual ~abstract_mech_account_t                       () {}                    /* destructor */
};

} /* namespace mech */
} /* namespace exchange */
} /* namespace camahjucunu */
} /* namespace cuwacunu */

```

===== FILE: abstract/abstract_mech_data.h (bytes=1862, lines=32, sha256=c94da16bea2a0363450436739f2cabb79da9f3f588a9b16d4b6fa917d33cdd61) =====
```c
#pragma once
#include "piaabo/dutils.h"
#include "piaabo/darchitecture.h"
#include "camahjucunu/exchange/exchange_utils.h"
#include "camahjucunu/exchange/exchange_types_data.h"
#include "camahjucunu/exchange/exchange_types_enums.h"

namespace cuwacunu {
namespace camahjucunu {
namespace exchange {
namespace mech {

/* --- --- --- --- --- --- --- --- --- --- --- */
/*         virtual exchange structure          */
/* --- --- --- --- --- --- --- --- --- --- --- */
struct abstract_mech_data_t {
  virtual std::optional<depth_ret_t>            depth             (            depth_args_t args, bool await = true )  const = 0;
  virtual std::optional<tradesRecent_ret_t>     tradesRecent      (     tradesRecent_args_t args, bool await = true )  const = 0;
  virtual std::optional<tradesHistorical_ret_t> tradesHistorical  ( tradesHistorical_args_t args, bool await = true )  const = 0;
  virtual std::optional<klines_ret_t>           klines            (           klines_args_t args, bool await = true )  const = 0;
  virtual std::optional<avgPrice_ret_t>         avgPrice          (         avgPrice_args_t args, bool await = true )  const = 0;
  virtual std::optional<ticker_ret_t>           ticker            (           ticker_args_t args, bool await = true )  const = 0;
  virtual std::optional<tickerTradingDay_ret_t> ticker_tradingDay ( tickerTradingDay_args_t args, bool await = true )  const = 0;
  virtual std::optional<tickerPrice_ret_t>      tickerPrice       (      tickerPrice_args_t args, bool await = true )  const = 0;
  virtual std::optional<tickerBook_ret_t>       tickerBook        (       tickerBook_args_t args, bool await = true )  const = 0;
  virtual ~abstract_mech_data_t                  () {}             /* destructor */
};

} /* namespace mech */
} /* namespace exchange */
} /* namespace camahjucunu */
} /* namespace cuwacunu */

```

===== FILE: abstract/abstract_mech_server.h (bytes=858, lines=25, sha256=ee6f43f181c481ed2a1972bc72a88a81c862f84d104b72b0bbcac2e3c826a1e2) =====
```c
#pragma once
#include "piaabo/dutils.h"
#include "piaabo/darchitecture.h"
#include "camahjucunu/exchange/exchange_utils.h"
#include "camahjucunu/exchange/exchange_types_server.h"
#include "camahjucunu/exchange/exchange_types_enums.h"

namespace cuwacunu {
namespace camahjucunu {
namespace exchange {
namespace mech {

/* --- --- --- --- --- --- --- --- --- --- --- */
/*         virtual exchange structure          */
/* --- --- --- --- --- --- --- --- --- --- --- */
struct abstract_mech_server_t {
  virtual std::optional<ping_ret_t> ping ( ping_args_t args, bool await = true )  const = 0;
  virtual std::optional<time_ret_t> time ( time_args_t args, bool await = true )  const = 0;
  virtual ~abstract_mech_server_t    () {} /* destructor */
};

} /* namespace mech */
} /* namespace exchange */
} /* namespace camahjucunu */
} /* namespace cuwacunu */

```

===== FILE: abstract/abstract_mech_trade.h (bytes=2414, lines=33, sha256=72137113c43e1e521af230d85e43d4a42b8151eef97ff16c4a5f905f164c9650) =====
```c
#pragma once
#include "piaabo/dutils.h"
#include "piaabo/darchitecture.h"
#include "camahjucunu/exchange/exchange_utils.h"
#include "camahjucunu/exchange/exchange_types_trade.h"
#include "camahjucunu/exchange/exchange_types_enums.h"

namespace cuwacunu {
namespace camahjucunu {
namespace exchange {
namespace mech {

/* --- --- --- --- --- --- --- --- --- --- --- */
/*         virtual exchange structure          */
/* --- --- --- --- --- --- --- --- --- --- --- */
struct abstract_mech_trade_t {
  virtual std::optional<order_ret_t>                order                ( order_type_e type, order_args_t args, bool testOrder = false, bool await = true )  const = 0;
  virtual std::optional<orderStatus_ret_t>          orderStatus          ( orderStatus_args_t args, bool await = true )                                       const = 0;
  virtual std::optional<orderMarket_ret_t>          orderMarket          ( orderMarket_args_t args, bool testOrder = false, bool await = true )               const = 0;
  // virtual std::optional<orderLimit_ret_t>           orderLimit           ( orderLimit_args_t args, bool testOrder = false, bool await = true )                const = 0;
  // virtual std::optional<orderStopLoss_ret_t>        orderStopLoss        ( orderStopLoss_args_t args, bool testOrder = false, bool await = true )             const = 0;
  // virtual std::optional<orderStopLossLimit_ret_t>   orderStopLossLimit   ( orderStopLossLimit_args_t args, bool testOrder = false, bool await = true )        const = 0;
  // virtual std::optional<orderTakeProfit_ret_t>      orderTakeProfit      ( orderTakeProfit_args_t args, bool testOrder = false, bool await = true )           const = 0;
  // virtual std::optional<orderTakeProfitLimit_ret_t> orderTakeProfitLimit ( orderTakeProfitLimit_args_t args, bool testOrder = false, bool await = true )      const = 0;
  // virtual std::optional<orderLimitMaker_ret_t>      orderLimitMaker      ( orderLimitMaker_args_t args, bool testOrder = false, bool await = true )           const = 0;
  // virtual std::optional<orderSor_ret_t>             orderSor             ( orderSor_args_t args, bool testOrder = false, bool await = true )                  const = 0;  
  virtual ~abstract_mech_trade_t                     () {}                /* destructor */
};

} /* namespace mech */
} /* namespace exchange */
} /* namespace camahjucunu */
} /* namespace cuwacunu */

```

===== FILE: binance/binance_mech_account.h (bytes=1266, lines=32, sha256=50f1b8799fd0c54a326bf4f4ec09698c88e9958e2b3273f7d1ec408308abd865) =====
```c
/* binance_mech_account.h */
#pragma once
#include "camahjucunu/exchange/abstract/abstract_mech_account.h"
#include "camahjucunu/exchange/binance/binance_utils.h"

namespace cuwacunu {
namespace camahjucunu {
namespace exchange {
namespace mech {
namespace binance {
struct binance_mech_account_t: public abstract_mech_account_t {
/* variables */
public:
  bool owns_session;
  cuwacunu::camahjucunu::curl::ws_session_id_t session_id;
public:
  /* constructor */
  binance_mech_account_t(cuwacunu::camahjucunu::curl::ws_session_id_t _session_id = NULL_CURL_SESSION);
  ~binance_mech_account_t();
  
  /* methods */
  std::optional<account_information_ret_t> account_information(account_information_args_t args, bool await) const override;
  std::optional<account_order_history_ret_t> account_order_history(account_order_history_args_t args, bool await) const override;
  std::optional<account_trade_list_ret_t> account_trade_list(account_trade_list_args_t args, bool await) const override;
  std::optional<account_commission_rates_ret_t> account_commission_rates(account_commission_rates_args_t args, bool await) const override;
};

} /* namespace binance */
} /* namespace mech */
} /* namespace exchange */
} /* namespace camahjucunu */
} /* namespace cuwacunu */

```

===== FILE: binance/binance_mech_data.h (bytes=1580, lines=36, sha256=a352c49681debfe71243e04bce832e20da23f307f184888905cc20029c3346b0) =====
```c
#pragma once
#include "camahjucunu/exchange/abstract/abstract_mech_data.h"
#include "camahjucunu/exchange/binance/binance_utils.h"

namespace cuwacunu {
namespace camahjucunu {
namespace exchange {
namespace mech {
namespace binance {
struct binance_mech_data_t: public abstract_mech_data_t {
/* variables */
public:
  bool owns_session;
  cuwacunu::camahjucunu::curl::ws_session_id_t session_id;
public:
  /* constructor */
  binance_mech_data_t(cuwacunu::camahjucunu::curl::ws_session_id_t _session_id = NULL_CURL_SESSION);
  ~binance_mech_data_t();

  /* methods */
  std::optional<depth_ret_t> depth(depth_args_t args, bool await) const override;
  std::optional<klines_ret_t> klines(klines_args_t args, bool await) const override;
  std::optional<avgPrice_ret_t> avgPrice(avgPrice_args_t args, bool await) const override;
  std::optional<ticker_ret_t> ticker(ticker_args_t args, bool await) const override;
  std::optional<tickerTradingDay_ret_t> ticker_tradingDay(tickerTradingDay_args_t args, bool await) const override;
  std::optional<tickerPrice_ret_t> tickerPrice(tickerPrice_args_t args, bool await) const override;
  std::optional<tickerBook_ret_t> tickerBook(tickerBook_args_t args, bool await) const override;
  std::optional<tradesRecent_ret_t> tradesRecent(tradesRecent_args_t args, bool await) const override;
  std::optional<tradesHistorical_ret_t> tradesHistorical(tradesHistorical_args_t args, bool await) const override;
};

} /* namespace binance */
} /* namespace mech */
} /* namespace exchange */
} /* namespace camahjucunu */
} /* namespace cuwacunu */

```

===== FILE: binance/binance_mech_server.h (bytes=874, lines=29, sha256=0c558bae0cfd1915528b0e9ca29365a5988bd757bd08f851964c6d9d0c883566) =====
```c
#pragma once
#include "camahjucunu/exchange/abstract/abstract_mech_server.h"
#include "camahjucunu/exchange/binance/binance_utils.h"

namespace cuwacunu {
namespace camahjucunu {
namespace exchange {
namespace mech {
namespace binance {
struct binance_mech_server_t: public abstract_mech_server_t {
/* variables */
public:
  bool owns_session;
  cuwacunu::camahjucunu::curl::ws_session_id_t session_id;
public:
  /* constructor */
  binance_mech_server_t(cuwacunu::camahjucunu::curl::ws_session_id_t _session_id = NULL_CURL_SESSION);
  ~binance_mech_server_t();

  /* methods */
  std::optional<ping_ret_t> ping(ping_args_t args, bool await) const override;
  std::optional<time_ret_t> time(time_args_t args, bool await) const override;
};

} /* namespace binance */
} /* namespace mech */
} /* namespace exchange */
} /* namespace camahjucunu */
} /* namespace cuwacunu */

```

===== FILE: binance/binance_mech_trade.h (bytes=1043, lines=30, sha256=e18970c78a409a55d5fcfa7e35cd99fb9cec3e8c8630b7daa341e4f2262ee33f) =====
```c
#pragma once
#include "camahjucunu/exchange/abstract/abstract_mech_trade.h"
#include "camahjucunu/exchange/binance/binance_utils.h"

namespace cuwacunu {
namespace camahjucunu {
namespace exchange {
namespace mech {
namespace binance {
struct binance_mech_trade_t: public abstract_mech_trade_t {
/* variables */
public:
  bool owns_session;
  cuwacunu::camahjucunu::curl::ws_session_id_t session_id;
public:
  /* constructor */
  binance_mech_trade_t(cuwacunu::camahjucunu::curl::ws_session_id_t _session_id = NULL_CURL_SESSION);
  ~binance_mech_trade_t();

  /* methods */
  std::optional<order_ret_t> order(order_type_e type, order_args_t args, bool testOrder, bool await)const override;
  std::optional<orderStatus_ret_t> orderStatus(orderStatus_args_t args, bool await) const override;
  std::optional<orderMarket_ret_t> orderMarket(orderMarket_args_t args, bool testOrder, bool await) const override;
};

} /* namespace binance */
} /* namespace mech */
} /* namespace exchange */
} /* namespace camahjucunu */
} /* namespace cuwacunu */

```

===== FILE: binance/binance_utils.h (bytes=5302, lines=143, sha256=3155b109eebd356b535cef4d8f092b16f19189f7aed647e2f189a0ac7ddb64ee) =====
```c
/* binance_utils.h */
#pragma once
#include "piaabo/dutils.h"
#include "piaabo/dconfig.h"
#include "piaabo/darchitecture.h"
#include "camahjucunu/https/curl_toolkit/websockets_api/curl_websocket_api.h"

/* # Methods (check if all of these are implemented)
    ping
    time
    exchangeInfo
    depth
    trades.recent
    trades.historical
    trades.aggregate
    klines
    uiKlines
    avgPrice
    ticker.24hr
    ticker.tradingDay
    ticker
    ticker.price
    ticker.book
    session.logon
    session.status
    session.logout
    order.place
    order.test
    order.status
    order.cancel
    order.cancelReplace
    openOrders.status
    openOrders.cancelAll
    orderList.place
    orderList.place.oco
    orderList.place.oto
    orderList.place.otoco
    orderList.status
    orderList.cancel
    openOrderLists.status
    sor.order.place
    sor.order.test
    account.status
    account.rateLimits.orders
    allOrders
    allOrderLists
    myTrades
    myPreventedMatches
    myAllocations
    account.commission
    userDataStream.start
    userDataStream.ping
    userDataStream.stop
*/

#define FORMAT_FRAME(frame_id, method, args) \
  FORMAT_STRING("{\"id\":\"%s\",\"method\":\"%s\",\"params\":%s}", \
    frame_id.c_str(), method, args.jsonify().c_str())

#define SEND_AND_RETRIVE_FRAME(session_id, frame_id, method, args, await, response) \
    /* compute the frame id */ \
    const std::string frame_id_format = method + std::string("-xxxx-xxxx"); \
    std::string frame_id = cuwacunu::piaabo::generate_random_string(frame_id_format); \
    cuwacunu::piaabo::string_replace(frame_id, '.', '_'); \
    /* format and send the frame message */ \
    cuwacunu::camahjucunu::curl::WebsocketAPI::ws_write_text( \
      session_id, FORMAT_FRAME(frame_id, method, args), frame_id \
    ); \
    /* no awaiting for response case */ \
    if(!await) { \
      return std::nullopt; \
    } \
    /* await and retrive server response */ \
    std::optional<cuwacunu::camahjucunu::curl::ws_incomming_data_t> response =  \
      cuwacunu::camahjucunu::curl::WebsocketAPI::ws_await_and_retrive_server_response(session_id, frame_id); \
    /* handle failure case */ \
    if(!response.has_value()) { \
      log_fatal("Websocket server failed to respond to [ %s ] method, for session_id[ %d ] in frame_id[ %s ]\n",  \
        method, session_id, frame_id.c_str()); \
      return std::nullopt; \
    }

#define SIGN_SEND_AND_RETRIVE_FRAME(session_id, frame_id, method, args, await, response) \
    /* compute the frame id */ \
    const std::string frame_id_format = method + std::string("-xxxx-xxxx"); \
    std::string frame_id = cuwacunu::piaabo::generate_random_string(frame_id_format); \
    cuwacunu::piaabo::string_replace(frame_id, '.', '_'); \
    /* */ \
    args.add_signature(); \
    /* format and send the frame message */ \
    cuwacunu::camahjucunu::curl::WebsocketAPI::ws_write_text( \
      session_id, FORMAT_FRAME(frame_id, method, args), frame_id \
    ); \
    /* no awaiting for response case */ \
    if(!await) { \
      return std::nullopt; \
    } \
    /* await and retrive server response */ \
    std::optional<cuwacunu::camahjucunu::curl::ws_incomming_data_t> response =  \
      cuwacunu::camahjucunu::curl::WebsocketAPI::ws_await_and_retrive_server_response(session_id, frame_id); \
    /* handle failure case */ \
    if(!response.has_value()) { \
      log_fatal("Websocket server failed to respond to [ %s ] method, for session_id[ %d ] in frame_id[ %s ]\n",  \
        method, session_id, frame_id.c_str()); \
      return std::nullopt; \
    }

#define DESERIALIZE_FRAME(object, response) \
  cuwacunu::camahjucunu::exchange::object(response.value().data);

#define NOTIFY_INIT(mech_type) \
  switch(cuwacunu::piaabo::dconfig::config_space_t::exchange_type) { \
    case cuwacunu::piaabo::dconfig::exchange_type_e::REAL: \
      log_info("\tStarting Binance [%sREAL%s] %s%s%s.\n", \
        ANSI_COLOR_Green, ANSI_COLOR_RESET, ANSI_COLOR_Blue, mech_type, ANSI_COLOR_RESET); \
      break; \
    case cuwacunu::piaabo::dconfig::exchange_type_e::TEST: \
      log_info("\tStarting Binance [%sTESTNET%s] %s%s%s.\n", \
        ANSI_COLOR_Green, ANSI_COLOR_RESET, ANSI_COLOR_Blue, mech_type, ANSI_COLOR_RESET); \
      break; \
    case cuwacunu::piaabo::dconfig::exchange_type_e::NONE: \
      log_terminate_gracefully("[%s]() %s, terminating program.\n", \
        mech_type, "Request to start in Binance Mech without prior reading configuration"); \
      break; \
  }

#define FORBIT_REAL_MECH(mech_type) \
  if(cuwacunu::piaabo::dconfig::config_space_t::exchange_type == cuwacunu::piaabo::dconfig::exchange_type_e::REAL) { \
      log_terminate_gracefully("%s %s %s. %s, terminating program.\n", \
        "[cuwacunu::camahjucunu::exchange::mech::binance::...](): ", \
        "Request to start", mech_type, \
        "Are you out of your mind?"); \
  }

#define ASSERT_SESSION(session_id, owns_session) \
  /* if no websocket session_id is passed, then generate one */ \
  if((owns_session = (session_id == NULL_CURL_SESSION))) { \
    /* start the websocket session */ \
    session_id = cuwacunu::camahjucunu::curl::WebsocketAPI::ws_init( \
      /* websocket_url */ \
      cuwacunu::piaabo::dconfig::config_space_t::websocket_url() \
    ); \
  }

```

===== FILE: binance/README.md (bytes=82, lines=2, sha256=446d6f630c00e0f63e4c2ec6b83d7b54885a637faeec23052c8b5489ecd2d7db) =====
```markdown
# Binance

All intereractions with the broker are done via websocket integration. 
```

===== FILE: exchange_types_account.h (bytes=4867, lines=59, sha256=65abd4c5ba1edcdb3cc3b762011c2e22ab85eeb88085f6990affdbad0055aed3) =====
```c
/* exchange_types_account.h */
#pragma once
#include "camahjucunu/exchange/exchange_utils.h"
#include "camahjucunu/exchange/exchange_types_trade.h"

namespace cuwacunu {
namespace camahjucunu {
namespace exchange {

/* --- --- --- --- --- --- --- --- --- --- --- */
/*            arguments structures             */
/* --- --- --- --- --- --- --- --- --- --- --- */
struct account_information_args_t       { void add_signature(); std::string jsonify(); std::optional<bool> omitZeroBalances = std::nullopt; std::optional<long> recvWindow = std::nullopt; std::string apiKey; std::string signature; long timestamp; };
struct account_order_history_args_t     { void add_signature(); std::string jsonify(); std::string symbol; std::optional<int> orderId = std::nullopt; std::optional<long> startTime = std::nullopt; std::optional<long> endTime = std::nullopt; std::optional<long> limit = std::nullopt; std::optional<long> recvWindow = std::nullopt; std::string apiKey; std::string signature; long timestamp; };
struct account_trade_list_args_t        { void add_signature(); std::string jsonify(); std::string symbol; std::optional<int> orderId = std::nullopt; std::optional<long> startTime = std::nullopt; std::optional<long> endTime = std::nullopt; std::optional<int> fromId = std::nullopt; std::optional<int> limit = std::nullopt; std::optional<long> recvWindow = std::nullopt; std::string apiKey; std::string signature; long timestamp; };
struct account_commission_rates_args_t  { void add_signature(); std::string jsonify(); std::string symbol; std::string apiKey; std::string signature; long timestamp; };
ENFORCE_ARCHITECTURE_DESIGN(      account_information_args_t);
ENFORCE_ARCHITECTURE_DESIGN(    account_order_history_args_t);
ENFORCE_ARCHITECTURE_DESIGN(       account_trade_list_args_t);
ENFORCE_ARCHITECTURE_DESIGN( account_commission_rates_args_t);

/* --- --- --- --- --- --- --- --- --- --- --- */
/*         expected return structures          */
/* --- --- --- --- --- --- --- --- --- --- --- */

/* secondary return structs */
struct balance_t             { std::string asset; double free; double locked; };
struct historicTrade_t       { std::string symbol; int id; int orderId; int orderListId; double price; double qty; double quoteQty; double commission; std::string commissionAsset; long time; bool isBuyer; bool isMaker; bool isBestMatch; };
struct commissionRates_t     { double maker; double taker; double buyer; double seller; };
struct commission_discount_t { bool enabledForAccount; bool enabledForSymbol; std::string discountAsset; double discount; };
struct commissionDesc_t      { std::string symbol; commissionRates_t standardCommission; commissionRates_t taxCommission; commission_discount_t discount; };
ENFORCE_ARCHITECTURE_DESIGN(             balance_t);
ENFORCE_ARCHITECTURE_DESIGN(       historicTrade_t);
ENFORCE_ARCHITECTURE_DESIGN(     commissionRates_t);
ENFORCE_ARCHITECTURE_DESIGN( commission_discount_t);
ENFORCE_ARCHITECTURE_DESIGN(      commissionDesc_t);

/* primary return structs */
struct account_information_ret_t      { frame_response_t frame_rsp; account_information_ret_t(const std::string &json); int makerCommission; int takerCommission; int buyerCommission; int sellerCommission; commissionRates_t commissionRates; bool canTrade; bool canWithdraw; bool canDeposit; bool brokered; bool requireSelfTradePrevention; bool preventSor; long updateTime; account_and_symbols_permissions_e accountType; std::vector<balance_t> balances; std::vector<account_and_symbols_permissions_e> permissions; long uid; };
struct account_order_history_ret_t    { frame_response_t frame_rsp; account_order_history_ret_t(const std::string &json); std::vector<orderStatus_ret_t> orders; };
struct account_trade_list_ret_t       { frame_response_t frame_rsp; account_trade_list_ret_t(const std::string &json); std::vector<historicTrade_t> trades; };
struct account_commission_rates_ret_t { frame_response_t frame_rsp; account_commission_rates_ret_t(const std::string &json); commissionDesc_t commissionDesc; };
ENFORCE_ARCHITECTURE_DESIGN(      account_information_ret_t);
ENFORCE_ARCHITECTURE_DESIGN(    account_order_history_ret_t);
ENFORCE_ARCHITECTURE_DESIGN(       account_trade_list_ret_t);
ENFORCE_ARCHITECTURE_DESIGN( account_commission_rates_ret_t);

/* --- --- --- --- --- --- --- --- --- --- --- */
/*         deserialize specializations         */
/* --- --- --- --- --- --- --- --- --- --- --- */

void deserialize(account_information_ret_t& deserialized, const std::string &json);
void deserialize(account_order_history_ret_t& deserialized, const std::string &json);
void deserialize(account_trade_list_ret_t& deserialized, const std::string &json);
void deserialize(account_commission_rates_ret_t& deserialized, const std::string &json);

} /* namespace exchange */
} /* namespace camahjucunu */
} /* namespace cuwacunu */

```

===== FILE: exchange_types_data.h (bytes=9412, lines=151, sha256=d7dd0ae8a67ded9873aca192241261ef8f67c515947b33a829000c6628613621) =====
```c
/* exchange_types_data.h */
#pragma once
#include "piaabo/math_compat/statistics_space.h"
#include "camahjucunu/exchange/exchange_utils.h"

namespace cuwacunu {
namespace camahjucunu {
namespace exchange {

/* --- --- --- --- --- --- --- --- --- --- --- */
/*      arguments structures       */
/* --- --- --- --- --- --- --- --- --- --- --- */
struct depth_args_t       { std::string jsonify(); std::string symbol; std::optional<int> limit = std::nullopt; };
struct tradesRecent_args_t      { std::string jsonify(); std::string symbol; std::optional<int> limit = std::nullopt; };
struct tradesHistorical_args_t    { std::string jsonify(); std::string symbol; std::optional<int> limit = std::nullopt; std::optional<long> fromId = std::nullopt; };
struct klines_args_t          { std::string jsonify(); std::string symbol; interval_type_e interval; std::optional<long> startTime = std::nullopt; std::optional<long> endTime = std::nullopt; std::optional<std::string> timeZone = std::nullopt; std::optional<int> limit = std::nullopt; };
struct avgPrice_args_t        { std::string jsonify(); std::string symbol; };
struct ticker_args_t          { std::string jsonify(); std::variant<std::string, std::vector<std::string>> symbol; std::optional<ticker_interval_e> windowSize = std::nullopt; std::optional<ticker_type_e> type = std::nullopt; };
struct tickerTradingDay_args_t    { std::string jsonify(); std::variant<std::string, std::vector<std::string>> symbol; std::optional<ticker_type_e> type = std::nullopt; std::optional<std::string> timeZone = std::nullopt; };
struct tickerPrice_args_t    { std::string jsonify(); std::variant<std::string, std::vector<std::string>> symbol; };
struct tickerBook_args_t        { std::string jsonify(); std::variant<std::string, std::vector<std::string>> symbol; };
ENFORCE_ARCHITECTURE_DESIGN(          depth_args_t);
ENFORCE_ARCHITECTURE_DESIGN(   tradesRecent_args_t);
ENFORCE_ARCHITECTURE_DESIGN( tradesHistorical_args_t);
ENFORCE_ARCHITECTURE_DESIGN(       klines_args_t);
ENFORCE_ARCHITECTURE_DESIGN(     avgPrice_args_t);
ENFORCE_ARCHITECTURE_DESIGN(       ticker_args_t);
ENFORCE_ARCHITECTURE_DESIGN( tickerTradingDay_args_t);
ENFORCE_ARCHITECTURE_DESIGN(    tickerPrice_args_t);
ENFORCE_ARCHITECTURE_DESIGN(     tickerBook_args_t);

/* --- --- --- --- --- --- --- --- --- --- --- */
/*     expected return structures    */
/* --- --- --- --- --- --- --- --- --- --- --- */

/* secondary return structs */
struct price_qty_t       { double price; double qty; };

struct tick_full_t       { std::string symbol; double priceChange; double priceChangePercent; double weightedAvgPrice; double prevClosePrice; 
                           double lastPrice; double lastQty; double bidPrice; double bidQty; double askPrice; double askQty; double openPrice; 
                           double highPrice; double lowPrice; double volume; double quoteVolume; long openTime; long closeTime; long firstId; int lastId; int count; };

struct tick_mini_t       { std::string symbol; double lastPrice; double openPrice; double highPrice; double lowPrice; double volume; 
                          double quoteVolume; long openTime; long closeTime; long firstId; int lastId; int count; };


#pragma pack(push, 1) /* ensure binary conversion compatibility and memory efficiency */
struct trade_t         {
  using key_type_t = int64_t;
  /* Methods */
  static constexpr std::size_t key_offset() { return offsetof(trade_t, time); }
  key_type_t key_value();
  static trade_t null_instance(key_type_t key_value = INT64_MIN);
  static trade_t from_binary(const char* data);
  static trade_t from_csv(const std::string& line, char delimiter = ',', size_t line_number = 0); 
  static statistics_pack_t<trade_t> initialize_statistics_pack(unsigned int window_size = 100);
  std::vector<double> tensor_features() const;
  void to_csv(std::ostream& os, char delimiter = ',') const;
  bool is_valid() const;
  /* Values */
  int64_t id; double price; double qty; double quoteQty; int64_t time; bool isBuyerMaker; bool isBestMatch;
};
#pragma pack(pop)


#pragma pack(push, 1) /* ensure binary conversion compatibility and memory efficiency */
struct kline_t         {
  using key_type_t = int64_t;
  /* Methods */
  static constexpr std::size_t key_offset() { return offsetof(kline_t, close_time); }
  key_type_t key_value();
  static kline_t from_binary(const char* data);
  static kline_t null_instance(key_type_t key_value = INT64_MIN);
  static kline_t from_csv(const std::string& line, char delimiter = ',', size_t line_number = 0); 
  static statistics_pack_t<kline_t> initialize_statistics_pack(unsigned int window_size = 100);
  std::vector<double> tensor_features() const; 
  void to_csv(std::ostream& os, char delimiter = ',') const;
  bool is_valid() const;
  /* Values */
  int64_t open_time; double open_price; double high_price; double low_price; double close_price; double volume; int64_t close_time; 
  double quote_asset_volume; int32_t number_of_trades; double taker_buy_base_volume; double taker_buy_quote_volume;
};
#pragma pack(pop)

#pragma pack(push, 1) /* ensure binary conversion compatibility and memory efficiency */
struct basic_t         {
  using key_type_t = double;
  /* Methods */
  static constexpr std::size_t key_offset() { return offsetof(basic_t, time); }
  key_type_t key_value();
  static basic_t from_binary(const char* data);
  static basic_t null_instance(key_type_t key_value = std::numeric_limits<double>::min());
  static basic_t from_csv(const std::string& line, char delimiter = ',', size_t line_number = 0); 
  static statistics_pack_t<basic_t> initialize_statistics_pack(unsigned int window_size = 100);
  std::vector<double> tensor_features() const; 
  void to_csv(std::ostream& os, char delimiter = ',') const;
  bool is_valid() const;
  /* Values */
  double time; double value;
};
#pragma pack(pop)

struct price_t         { std::string symbol; double price; };

struct bookPrice_t     { std::string symbol; double bidPrice; double bidQty; double askPrice; double askQty; };

ENFORCE_ARCHITECTURE_DESIGN(  price_qty_t);
ENFORCE_ARCHITECTURE_DESIGN(  tick_full_t);
ENFORCE_ARCHITECTURE_DESIGN(  tick_mini_t);
ENFORCE_ARCHITECTURE_DESIGN(      trade_t);
ENFORCE_ARCHITECTURE_DESIGN(      kline_t);
ENFORCE_ARCHITECTURE_DESIGN(      price_t);
ENFORCE_ARCHITECTURE_DESIGN(  bookPrice_t);

/* primary return structs */
struct depth_ret_t            { frame_response_t frame_rsp; depth_ret_t             (const std::string& json); long lastUpdateId; std::vector<price_qty_t> bids; std::vector<price_qty_t> asks; };
struct tradesRecent_ret_t     { frame_response_t frame_rsp; tradesRecent_ret_t      (const std::string& json); std::vector<trade_t> trades; };
struct tradesHistorical_ret_t { frame_response_t frame_rsp; tradesHistorical_ret_t  (const std::string& json); std::vector<trade_t> trades; };
struct klines_ret_t           { frame_response_t frame_rsp; klines_ret_t            (const std::string& json); std::vector<kline_t> klines; };
struct avgPrice_ret_t         { frame_response_t frame_rsp; avgPrice_ret_t          (const std::string& json); int mins; double price; long close_time; };
struct ticker_ret_t           { frame_response_t frame_rsp; ticker_ret_t            (const std::string& json); std::variant<std::monostate, tick_full_t, tick_mini_t, std::vector<tick_full_t>, std::vector<tick_mini_t>> ticks; bool is_full; };
struct tickerTradingDay_ret_t { frame_response_t frame_rsp; tickerTradingDay_ret_t  (const std::string& json); std::variant<std::monostate, tick_full_t, tick_mini_t, std::vector<tick_full_t>, std::vector<tick_mini_t>> ticks; bool is_full; };
struct tickerPrice_ret_t      { frame_response_t frame_rsp; tickerPrice_ret_t       (const std::string& json); std::variant<std::monostate, price_t, std::vector<price_t>> prices; };
struct tickerBook_ret_t       { frame_response_t frame_rsp; tickerBook_ret_t        (const std::string& json); std::variant<std::monostate, bookPrice_t, std::vector<bookPrice_t>> bookPrices; };
ENFORCE_ARCHITECTURE_DESIGN(            depth_ret_t);
ENFORCE_ARCHITECTURE_DESIGN(     tradesRecent_ret_t);
ENFORCE_ARCHITECTURE_DESIGN( tradesHistorical_ret_t);
ENFORCE_ARCHITECTURE_DESIGN(           klines_ret_t);
ENFORCE_ARCHITECTURE_DESIGN(         avgPrice_ret_t);
ENFORCE_ARCHITECTURE_DESIGN(           ticker_ret_t);
ENFORCE_ARCHITECTURE_DESIGN( tickerTradingDay_ret_t);
ENFORCE_ARCHITECTURE_DESIGN(      tickerPrice_ret_t);
ENFORCE_ARCHITECTURE_DESIGN(       tickerBook_ret_t);

/* --- --- --- --- --- --- --- --- --- --- --- */
/*     deserialize specializations     */
/* --- --- --- --- --- --- --- --- --- --- --- */

void deserialize(depth_ret_t& deserialized, const std::string &json);
void deserialize(tradesRecent_ret_t& deserialized, const std::string &json);
void deserialize(tradesHistorical_ret_t& deserialized, const std::string &json);
void deserialize(klines_ret_t& deserialized, const std::string &json);
void deserialize(avgPrice_ret_t& deserialized, const std::string &json);
void deserialize(tickerTradingDay_ret_t& deserialized, const std::string &json);
void deserialize(ticker_ret_t& deserialized, const std::string &json);
void deserialize(tickerPrice_ret_t& deserialized, const std::string &json);
void deserialize(tickerBook_ret_t& deserialized, const std::string &json);

} /* namespace exchange */
} /* namespace camahjucunu */
} /* namespace cuwacunu */

```

===== FILE: exchange_types_enums.h (bytes=33680, lines=691, sha256=27cc7bf886b4a69a0dec987dc3cc823d4f77cd18bba48caf2876c69198601d4a) =====
```c
/* exchange_types_enums.h */
#pragma once
#include <string>
#include <type_traits>
#include <optional>
#include "piaabo/dutils.h"
#include "piaabo/darchitecture.h"

namespace cuwacunu {
namespace camahjucunu {
namespace exchange {
/* Generalities */
template <typename T> 
  struct EnumTraits;

template <typename T>
struct is_optional_enum : std::false_type {};

template <typename E>
struct is_optional_enum<std::optional<E>> : std::is_enum<E> {};

template <typename T>
std::string enum_to_string(T enumValue) {
  return EnumTraits<T>::toString(enumValue);
}

template <typename T>
T string_to_enum(const std::string& str) {
    return EnumTraits<T>::fromString(str);
}
/* interval_type_e */
enum class interval_type_e {
  /* utilities */ utility_constant, utility_sine, utility_triangular, 
  /* seconds */   interval_1s, 
  /* minutes */   interval_1m, interval_3m, interval_5m, interval_15m, interval_30m,
  /* hours */     interval_1h, interval_2h, interval_4h, interval_6h, interval_8h, interval_12h,
  /* days */      interval_1d, interval_3d,
  /* weeks */     interval_1w,
  /* month */     interval_1M
};
template <>
struct EnumTraits<interval_type_e> {
  static std::string toString(interval_type_e value) {
    switch (value) {
      case interval_type_e::utility_constant:   return "constant";
      case interval_type_e::utility_sine:       return "sine";
      case interval_type_e::utility_triangular: return "triangular";
      case interval_type_e::interval_1s:   return "1s";
      case interval_type_e::interval_1m:   return "1m";
      case interval_type_e::interval_3m:   return "3m";
      case interval_type_e::interval_5m:   return "5m";
      case interval_type_e::interval_15m:  return "15m";
      case interval_type_e::interval_30m:  return "30m";
      case interval_type_e::interval_1h:   return "1h";
      case interval_type_e::interval_2h:   return "2h";
      case interval_type_e::interval_4h:   return "4h";
      case interval_type_e::interval_6h:   return "6h";
      case interval_type_e::interval_8h:   return "8h";
      case interval_type_e::interval_12h:  return "12h";
      case interval_type_e::interval_1d:   return "1d";
      case interval_type_e::interval_3d:   return "3d";
      case interval_type_e::interval_1w:   return "1w";
      case interval_type_e::interval_1M:   return "1M";
      default: log_fatal("Unknown interval_type_e requested to convert into str.\n"); return "Unknown interval_type_e";
    }
  }
  static interval_type_e fromString(const std::string& str) {
    if (str == "constant")    return interval_type_e::utility_constant;
    if (str == "sine")        return interval_type_e::utility_sine;
    if (str == "triangular")  return interval_type_e::utility_triangular;
    if (str == "1s")     return interval_type_e::interval_1s;
    if (str == "1m")     return interval_type_e::interval_1m;
    if (str == "3m")     return interval_type_e::interval_3m;
    if (str == "5m")     return interval_type_e::interval_5m;
    if (str == "15m")    return interval_type_e::interval_15m;
    if (str == "30m")    return interval_type_e::interval_30m;
    if (str == "1h")     return interval_type_e::interval_1h;
    if (str == "2h")     return interval_type_e::interval_2h;
    if (str == "4h")     return interval_type_e::interval_4h;
    if (str == "6h")     return interval_type_e::interval_6h;
    if (str == "8h")     return interval_type_e::interval_8h;
    if (str == "12h")    return interval_type_e::interval_12h;
    if (str == "1d")     return interval_type_e::interval_1d;
    if (str == "3d")     return interval_type_e::interval_3d;
    if (str == "1w")     return interval_type_e::interval_1w;
    if (str == "1M")     return interval_type_e::interval_1M;
    log_fatal("Unknown string requested to convert into interval_type_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for interval_type_e");
  }
};

/* ticker_interval_e */
enum class ticker_interval_e {
  /* minutes */   interval_1m, interval_3m, interval_5m, interval_15m, interval_30m, 
  /* hours */     interval_1h, interval_2h, interval_3h, interval_4h, interval_5h, interval_6h, interval_7h, interval_8h, interval_9h, interval_10h, interval_11h, interval_12h, 
  /* days */      interval_1d, interval_2d, interval_3d, interval_4d, interval_5d, interval_6d, interval_7d
};
template <>
struct EnumTraits<ticker_interval_e> {
  static std::string toString(ticker_interval_e value) {
    switch (value) {
      case ticker_interval_e::interval_1m:    return "1m";
      case ticker_interval_e::interval_3m:    return "3m";
      case ticker_interval_e::interval_5m:    return "5m";
      case ticker_interval_e::interval_15m:   return "15m";
      case ticker_interval_e::interval_30m:   return "30m";
      case ticker_interval_e::interval_1h:    return "1h";
      case ticker_interval_e::interval_2h:    return "2h";
      case ticker_interval_e::interval_3h:    return "3h";
      case ticker_interval_e::interval_4h:    return "4h";
      case ticker_interval_e::interval_5h:    return "5h";
      case ticker_interval_e::interval_6h:    return "6h";
      case ticker_interval_e::interval_7h:    return "7h";
      case ticker_interval_e::interval_8h:    return "8h";
      case ticker_interval_e::interval_9h:    return "9h";
      case ticker_interval_e::interval_10h:   return "10h";
      case ticker_interval_e::interval_11h:   return "11h";
      case ticker_interval_e::interval_12h:   return "12h";
      case ticker_interval_e::interval_1d:    return "1d";
      case ticker_interval_e::interval_2d:    return "2d";
      case ticker_interval_e::interval_3d:    return "3d";
      case ticker_interval_e::interval_4d:    return "4d";
      case ticker_interval_e::interval_5d:    return "5d";
      case ticker_interval_e::interval_6d:    return "6d";
      case ticker_interval_e::interval_7d:    return "7d";
      default: log_fatal("Unknown ticker_interval_e requested to convert into str.\n"); return "Unknown ticker_interval_e";
    }
  }
  static ticker_interval_e fromString(const std::string& str) {
    if (str == "1m")    return ticker_interval_e::interval_1m;
    if (str == "3m")    return ticker_interval_e::interval_3m;
    if (str == "5m")    return ticker_interval_e::interval_5m;
    if (str == "15m")   return ticker_interval_e::interval_15m;
    if (str == "30m")   return ticker_interval_e::interval_30m;
    if (str == "1h")    return ticker_interval_e::interval_1h;
    if (str == "2h")    return ticker_interval_e::interval_2h;
    if (str == "3h")    return ticker_interval_e::interval_3h;
    if (str == "4h")    return ticker_interval_e::interval_4h;
    if (str == "5h")    return ticker_interval_e::interval_5h;
    if (str == "6h")    return ticker_interval_e::interval_6h;
    if (str == "7h")    return ticker_interval_e::interval_7h;
    if (str == "8h")    return ticker_interval_e::interval_8h;
    if (str == "9h")    return ticker_interval_e::interval_9h;
    if (str == "10h")   return ticker_interval_e::interval_10h;
    if (str == "11h")   return ticker_interval_e::interval_11h;
    if (str == "12h")   return ticker_interval_e::interval_12h;
    if (str == "1d")    return ticker_interval_e::interval_1d;
    if (str == "2d")    return ticker_interval_e::interval_2d;
    if (str == "3d")    return ticker_interval_e::interval_3d;
    if (str == "4d")    return ticker_interval_e::interval_4d;
    if (str == "5d")    return ticker_interval_e::interval_5d;
    if (str == "6d")    return ticker_interval_e::interval_6d;
    if (str == "7d")    return ticker_interval_e::interval_7d;
    log_fatal("Unknown string requested to convert into ticker_interval_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for ticker_interval_e");
  }
};

/* ticker_type_e */
enum class ticker_type_e {
  FULL,
  MINI
};
template <>
struct EnumTraits<ticker_type_e> {
  static std::string toString(ticker_type_e value) {
    switch (value) {
      case ticker_type_e::FULL:   return "FULL";
      case ticker_type_e::MINI:   return "MINI";
      default: log_fatal("Unknown ticker_type_e requested to convert into str.\n"); return "Unknown ticker_type_e";
    }
  }
  static ticker_type_e fromString(const std::string& str) {
    if (str == "FULL")    return ticker_type_e::FULL;
    if (str == "MINI")    return ticker_type_e::MINI;
    log_fatal("Unknown string requested to convert into ticker_type_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for ticker_type_e");
  }
};


/* Symbol status (status) */
enum class symbol_status_e {
  PRE_TRADING,    /* Status before the trading session begins */
  TRADING,        /* Status during the active trading session */
  POST_TRADING,   /* Status after the trading session ends */
  END_OF_DAY,     /* Status indicating the end of the trading day */
  HALT,           /* Status indicating that trading is temporarily halted */
  AUCTION_MATCH,  /* Status during an auction match period */
  BREAK           /* Status indicating a break in trading */
};
template <>
struct EnumTraits<symbol_status_e> {
  static std::string toString(symbol_status_e value) {
    switch (value) {
      case symbol_status_e::PRE_TRADING:    return "PRE_TRADING";
      case symbol_status_e::TRADING:        return "TRADING";
      case symbol_status_e::POST_TRADING:   return "POST_TRADING";
      case symbol_status_e::END_OF_DAY:     return "END_OF_DAY";
      case symbol_status_e::HALT:           return "HALT";
      case symbol_status_e::AUCTION_MATCH:  return "AUCTION_MATCH";
      case symbol_status_e::BREAK:          return "BREAK";
      default: log_fatal("Unknown symbol_status_e requested to convert into str.\n"); return "Unknown symbol_status_e";
    }
  }
  static symbol_status_e fromString(const std::string& str) {
    if (str == "PRE_TRADING")         return symbol_status_e::PRE_TRADING;
    if (str == "TRADING")             return symbol_status_e::TRADING;
    if (str == "POST_TRADING")        return symbol_status_e::POST_TRADING;
    if (str == "END_OF_DAY")          return symbol_status_e::END_OF_DAY;
    if (str == "HALT")                return symbol_status_e::HALT;
    if (str == "AUCTION_MATCH")       return symbol_status_e::AUCTION_MATCH;
    if (str == "BREAK")               return symbol_status_e::BREAK;
    log_fatal("Unknown string requested to convert into symbol_status_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for symbol_status_e");
  }
};

/* Account and Symbol Permissions (permissions) */
enum class account_and_symbols_permissions_e {
  SPOT,
  MARGIN,
  LEVERAGED,
  TRD_GRP_002,
  TRD_GRP_003,
  TRD_GRP_004,
  TRD_GRP_005,
  TRD_GRP_006,
  TRD_GRP_007,
  TRD_GRP_008,
  TRD_GRP_009,
  TRD_GRP_010,
  TRD_GRP_011,
  TRD_GRP_012,
  TRD_GRP_013,
  TRD_GRP_014,
  TRD_GRP_015,
  TRD_GRP_016,
  TRD_GRP_017,
  TRD_GRP_018,
  TRD_GRP_019,
  TRD_GRP_020,
  TRD_GRP_021,
  TRD_GRP_022,
  TRD_GRP_023,
  TRD_GRP_024,
  TRD_GRP_025
};
template <>
struct EnumTraits<account_and_symbols_permissions_e> {
  static std::string toString(account_and_symbols_permissions_e value) {
    switch (value) {
      case account_and_symbols_permissions_e::SPOT:        return "SPOT";
      case account_and_symbols_permissions_e::MARGIN:      return "MARGIN";
      case account_and_symbols_permissions_e::LEVERAGED:   return "LEVERAGED";
      case account_and_symbols_permissions_e::TRD_GRP_002: return "TRD_GRP_002";
      case account_and_symbols_permissions_e::TRD_GRP_003: return "TRD_GRP_003";
      case account_and_symbols_permissions_e::TRD_GRP_004: return "TRD_GRP_004";
      case account_and_symbols_permissions_e::TRD_GRP_005: return "TRD_GRP_005";
      case account_and_symbols_permissions_e::TRD_GRP_006: return "TRD_GRP_006";
      case account_and_symbols_permissions_e::TRD_GRP_007: return "TRD_GRP_007";
      case account_and_symbols_permissions_e::TRD_GRP_008: return "TRD_GRP_008";
      case account_and_symbols_permissions_e::TRD_GRP_009: return "TRD_GRP_009";
      case account_and_symbols_permissions_e::TRD_GRP_010: return "TRD_GRP_010";
      case account_and_symbols_permissions_e::TRD_GRP_011: return "TRD_GRP_011";
      case account_and_symbols_permissions_e::TRD_GRP_012: return "TRD_GRP_012";
      case account_and_symbols_permissions_e::TRD_GRP_013: return "TRD_GRP_013";
      case account_and_symbols_permissions_e::TRD_GRP_014: return "TRD_GRP_014";
      case account_and_symbols_permissions_e::TRD_GRP_015: return "TRD_GRP_015";
      case account_and_symbols_permissions_e::TRD_GRP_016: return "TRD_GRP_016";
      case account_and_symbols_permissions_e::TRD_GRP_017: return "TRD_GRP_017";
      case account_and_symbols_permissions_e::TRD_GRP_018: return "TRD_GRP_018";
      case account_and_symbols_permissions_e::TRD_GRP_019: return "TRD_GRP_019";
      case account_and_symbols_permissions_e::TRD_GRP_020: return "TRD_GRP_020";
      case account_and_symbols_permissions_e::TRD_GRP_021: return "TRD_GRP_021";
      case account_and_symbols_permissions_e::TRD_GRP_022: return "TRD_GRP_022";
      case account_and_symbols_permissions_e::TRD_GRP_023: return "TRD_GRP_023";
      case account_and_symbols_permissions_e::TRD_GRP_024: return "TRD_GRP_024";
      case account_and_symbols_permissions_e::TRD_GRP_025: return "TRD_GRP_025";
      default: log_fatal("Unknown account_and_symbols_permissions_e requested to convert into str.\n"); return "Unknown account_and_symbols_permissions_e";
    }
  }
  static account_and_symbols_permissions_e fromString(const std::string& str) {
    if (str == "SPOT")        return account_and_symbols_permissions_e::SPOT;
    if (str == "MARGIN")      return account_and_symbols_permissions_e::MARGIN;
    if (str == "LEVERAGED")   return account_and_symbols_permissions_e::LEVERAGED;
    if (str == "TRD_GRP_002") return account_and_symbols_permissions_e::TRD_GRP_002;
    if (str == "TRD_GRP_003") return account_and_symbols_permissions_e::TRD_GRP_003;
    if (str == "TRD_GRP_004") return account_and_symbols_permissions_e::TRD_GRP_004;
    if (str == "TRD_GRP_005") return account_and_symbols_permissions_e::TRD_GRP_005;
    if (str == "TRD_GRP_006") return account_and_symbols_permissions_e::TRD_GRP_006;
    if (str == "TRD_GRP_007") return account_and_symbols_permissions_e::TRD_GRP_007;
    if (str == "TRD_GRP_008") return account_and_symbols_permissions_e::TRD_GRP_008;
    if (str == "TRD_GRP_009") return account_and_symbols_permissions_e::TRD_GRP_009;
    if (str == "TRD_GRP_010") return account_and_symbols_permissions_e::TRD_GRP_010;
    if (str == "TRD_GRP_011") return account_and_symbols_permissions_e::TRD_GRP_011;
    if (str == "TRD_GRP_012") return account_and_symbols_permissions_e::TRD_GRP_012;
    if (str == "TRD_GRP_013") return account_and_symbols_permissions_e::TRD_GRP_013;
    if (str == "TRD_GRP_014") return account_and_symbols_permissions_e::TRD_GRP_014;
    if (str == "TRD_GRP_015") return account_and_symbols_permissions_e::TRD_GRP_015;
    if (str == "TRD_GRP_016") return account_and_symbols_permissions_e::TRD_GRP_016;
    if (str == "TRD_GRP_017") return account_and_symbols_permissions_e::TRD_GRP_017;
    if (str == "TRD_GRP_018") return account_and_symbols_permissions_e::TRD_GRP_018;
    if (str == "TRD_GRP_019") return account_and_symbols_permissions_e::TRD_GRP_019;
    if (str == "TRD_GRP_020") return account_and_symbols_permissions_e::TRD_GRP_020;
    if (str == "TRD_GRP_021") return account_and_symbols_permissions_e::TRD_GRP_021;
    if (str == "TRD_GRP_022") return account_and_symbols_permissions_e::TRD_GRP_022;
    if (str == "TRD_GRP_023") return account_and_symbols_permissions_e::TRD_GRP_023;
    if (str == "TRD_GRP_024") return account_and_symbols_permissions_e::TRD_GRP_024;
    if (str == "TRD_GRP_025") return account_and_symbols_permissions_e::TRD_GRP_025;
    log_fatal("Unknown string requested to convert into account_and_symbols_permissions_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for account_and_symbols_permissions_e");
  }
};

/* Order status (status) */
enum class orderStatus_e {
  NEW,                /* The order has been accepted by the engine. */
  PENDING_NEW,        /* The order is in a pending phase until the working order of an order list has been fully filled. */
  PARTIALLY_FILLED,   /* A part of the order has been filled. */
  FILLED,             /* The order has been completed. */
  CANCELED,           /* The order has been canceled by the user. */
  PENDING_CANCEL,     /* Currently unused */
  REJECTED,           /* The order was not accepted by the engine and not processed. */
  EXPIRED,            /* The order was canceled according to the order type's rules (e.g. LIMIT FOK orders with no fill, LIMIT IOC or MARKET orders that partially fill) or by the exchange, (e.g. orders canceled during liquidation, orders canceled during maintenance) */
  EXPIRED_IN_MATCH    /* The order was expired by the exchange due to STP. (e.g. an order with EXPIRE_TAKER will match with existing orders on the book with the same account or same tradeGroupId) */
};
template <>
struct EnumTraits<orderStatus_e> {
  static std::string toString(orderStatus_e value) {
    switch (value) {
      case orderStatus_e::NEW:               return "NEW";
      case orderStatus_e::PENDING_NEW:       return "PENDING_NEW";
      case orderStatus_e::PARTIALLY_FILLED:  return "PARTIALLY_FILLED";
      case orderStatus_e::FILLED:            return "FILLED";
      case orderStatus_e::CANCELED:          return "CANCELED";
      case orderStatus_e::PENDING_CANCEL:    return "PENDING_CANCEL";
      case orderStatus_e::REJECTED:          return "REJECTED";
      case orderStatus_e::EXPIRED:           return "EXPIRED";
      case orderStatus_e::EXPIRED_IN_MATCH:  return "EXPIRED_IN_MATCH";
      default: log_fatal("Unknown orderStatus_e requested to convert into str.\n"); return "Unknown orderStatus_e";
    }
  }
  static orderStatus_e fromString(const std::string& str) {
    if (str == "NEW")                 return orderStatus_e::NEW;
    if (str == "PENDING_NEW")         return orderStatus_e::PENDING_NEW;
    if (str == "PARTIALLY_FILLED")    return orderStatus_e::PARTIALLY_FILLED;
    if (str == "FILLED")              return orderStatus_e::FILLED;
    if (str == "CANCELED")            return orderStatus_e::CANCELED;
    if (str == "PENDING_CANCEL")      return orderStatus_e::PENDING_CANCEL;
    if (str == "REJECTED")            return orderStatus_e::REJECTED;
    if (str == "EXPIRED")             return orderStatus_e::EXPIRED;
    if (str == "EXPIRED_IN_MATCH")    return orderStatus_e::EXPIRED_IN_MATCH;
    log_fatal("Unknown string requested to convert into orderStatus_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for orderStatus_e");
  }
};

/* Order List Status (listStatusType) */
enum class order_list_status_e {
  RESPONSE,	      /* This is used when the ListStatus is responding to a failed action. (E.g. order list placement or cancellation) */
  EXEC_STARTED,	  /* The order list has been placed or there is an update to the order list status. */
  ALL_DONE	      /* The order list has finished executing and thus is no longer active. */
};
template <>
struct EnumTraits<order_list_status_e> {
  static std::string toString(order_list_status_e value) {
    switch (value) {
      case order_list_status_e::RESPONSE:      return "RESPONSE";
      case order_list_status_e::EXEC_STARTED:  return "EXEC_STARTED";
      case order_list_status_e::ALL_DONE:      return "ALL_DONE";
      default: log_fatal("Unknown order_list_status_e requested to convert into str.\n"); return "Unknown order_list_status_e";
    }
  }
  static order_list_status_e fromString(const std::string& str) {
    if (str == "RESPONSE")        return order_list_status_e::RESPONSE;
    if (str == "EXEC_STARTED")    return order_list_status_e::EXEC_STARTED;
    if (str == "ALL_DONE")        return order_list_status_e::ALL_DONE;
    log_fatal("Unknown string requested to convert into order_list_status_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for order_list_status_e");
  }
};

/* Order List Order Status (listOrderStatus) */
enum class order_list_orderStatus_e {
  EXECUTING,    /* Either an order list has been placed or there is an update to the status of the list. */
  ALL_DONE,     /* An order list has completed execution and thus no longer active. */
  REJECT        /* The List Status is responding to a failed action either during order placement or order canceled. */
};
template <>
struct EnumTraits<order_list_orderStatus_e> {
  static std::string toString(order_list_orderStatus_e value) {
    switch (value) {
      case order_list_orderStatus_e::EXECUTING:  return "EXECUTING";
      case order_list_orderStatus_e::ALL_DONE:   return "ALL_DONE";
      case order_list_orderStatus_e::REJECT:     return "REJECT";
      default: log_fatal("Unknown order_list_orderStatus_e requested to convert into str.\n"); return "Unknown order_list_orderStatus_e";
    }
  }
  static order_list_orderStatus_e fromString(const std::string& str) {
    if (str == "EXECUTING")   return order_list_orderStatus_e::EXECUTING;
    if (str == "ALL_DONE")    return order_list_orderStatus_e::ALL_DONE;
    if (str == "REJECT")      return order_list_orderStatus_e::REJECT;
    log_fatal("Unknown string requested to convert into order_list_orderStatus_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for order_list_orderStatus_e");
  }
};

/* ContingencyType */
enum class contingency_type_e {
  OCO, /* One Cancels the Other: When one order is executed, the other is automatically canceled. */
  OTO  /* One Triggers the Other: When the primary order is executed, it triggers the placement of the secondary order. */
};
template <>
struct EnumTraits<contingency_type_e> {
  static std::string toString(contingency_type_e value) {
    switch (value) {
      case contingency_type_e::OCO: return "OCO";
      case contingency_type_e::OTO: return "OTO";
      default: log_fatal("Unknown contingency_type_e requested to convert into str.\n"); return "Unknown contingency_type_e";
    }
  }
  static contingency_type_e fromString(const std::string& str) {
    if (str == "OCO") return contingency_type_e::OCO;
    if (str == "OTO") return contingency_type_e::OTO;
    log_fatal("Unknown string requested to convert into contingency_type_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for contingency_type_e");
  }
};

/* AllocationType */
enum class allocation_type_e {
  SOR
};
template <>
struct EnumTraits<allocation_type_e> {
  static std::string toString(allocation_type_e value) {
    switch (value) {
      case allocation_type_e::SOR:  return "SOR";
      default: log_fatal("Unknown allocation_type_e requested to convert into str.\n"); return "Unknown allocation_type_e";
    }
  }
  static allocation_type_e fromString(const std::string& str) {
    if (str == "SOR")   return allocation_type_e::SOR;
    log_fatal("Unknown string requested to convert into allocation_type_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for allocation_type_e");
  }
};

/* Order types (orderTypes, type) */
enum class order_type_e {
  LIMIT,
  MARKET,
  STOP_LOSS,
  STOP_LOSS_LIMIT,
  TAKE_PROFIT,
  TAKE_PROFIT_LIMIT,
  LIMIT_MAKER
};
template <>
struct EnumTraits<order_type_e> {
  static std::string toString(order_type_e value) {
    switch (value) {
      case order_type_e::LIMIT:               return "LIMIT";
      case order_type_e::MARKET:              return "MARKET";
      case order_type_e::STOP_LOSS:           return "STOP_LOSS";
      case order_type_e::STOP_LOSS_LIMIT:     return "STOP_LOSS_LIMIT";
      case order_type_e::TAKE_PROFIT:         return "TAKE_PROFIT";
      case order_type_e::TAKE_PROFIT_LIMIT:   return "TAKE_PROFIT_LIMIT";
      case order_type_e::LIMIT_MAKER:         return "LIMIT_MAKER";
      default: log_fatal("Unknown order_type_e requested to convert into str.\n"); return "Unknown order_type_e";
    }
  }
  static order_type_e fromString(const std::string& str) {
    if (str == "LIMIT")               return order_type_e::LIMIT;
    if (str == "MARKET")              return order_type_e::MARKET;
    if (str == "STOP_LOSS")           return order_type_e::STOP_LOSS;
    if (str == "STOP_LOSS_LIMIT")     return order_type_e::STOP_LOSS_LIMIT;
    if (str == "TAKE_PROFIT")         return order_type_e::TAKE_PROFIT;
    if (str == "TAKE_PROFIT_LIMIT")   return order_type_e::TAKE_PROFIT_LIMIT;
    if (str == "LIMIT_MAKER")         return order_type_e::LIMIT_MAKER;
    log_fatal("Unknown string requested to convert into order_type_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for order_type_e");
  }
};

/* Order Response Type (newOrderRespType) */
enum class order_response_type_e {
  ACK,
  RESULT,
  FULL
};
template <>
struct EnumTraits<order_response_type_e> {
  static std::string toString(order_response_type_e value) {
    switch (value) {
      case order_response_type_e::ACK:     return "ACK";
      case order_response_type_e::RESULT:  return "RESULT";
      case order_response_type_e::FULL:    return "FULL";
      default: log_fatal("Unknown order_response_type_e requested to convert into str.\n"); return "Unknown order_response_type_e";
    }
  }
  static order_response_type_e fromString(const std::string& str) {
    if (str == "ACK")     return order_response_type_e::ACK;
    if (str == "RESULT")  return order_response_type_e::RESULT;
    if (str == "FULL")    return order_response_type_e::FULL;
    log_fatal("Unknown string requested to convert into order_response_type_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for order_response_type_e");
  }
};

/* Working Floor */
enum class working_floor_e {
  EXCHANGE,
  SOR
};
template <>
struct EnumTraits<working_floor_e> {
  static std::string toString(working_floor_e value) {
    switch (value) {
      case working_floor_e::EXCHANGE: return "EXCHANGE";
      case working_floor_e::SOR:      return "SOR";
      default: log_fatal("Unknown working_floor_e requested to convert into str.\n"); return "Unknown working_floor_e";
    }
  }
  static working_floor_e fromString(const std::string& str) {
    if (str == "EXCHANGE")  return working_floor_e::EXCHANGE;
    if (str == "SOR")       return working_floor_e::SOR;
    log_fatal("Unknown string requested to convert into working_floor_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for working_floor_e");
  }
};

/* Order side (side) */
enum class order_side_e {
  BUY,
  SELL
};
template <>
struct EnumTraits<order_side_e> {
  static std::string toString(order_side_e value) {
    switch (value) {
      case order_side_e::BUY:   return "BUY";
      case order_side_e::SELL:  return "SELL";
      default: log_fatal("Unknown order_side_e requested to convert into str.\n"); return "Unknown order_side_e";
    }
  }
  static order_side_e fromString(const std::string& str) {
    if (str == "BUY")   return order_side_e::BUY;
    if (str == "SELL")  return order_side_e::SELL;
    log_fatal("Unknown string requested to convert into order_side_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for order_side_e");
  }
};

/* Time in force (timeInForce): This sets how long an order will be active before expiration. */
enum class time_in_force_e {
  GTC, /* Good Til Canceled. An order will be on the book unless the order is canceled. */
  IOC, /* Immediate Or Cancel. An order will try to fill the order as much as it can before the order expires. */
  FOK  /* Fill or Kill. An order will expire if the full order cannot be filled upon execution. */
};
template <>
struct EnumTraits<time_in_force_e> {
  static std::string toString(time_in_force_e value) {
    switch (value) {
      case time_in_force_e::GTC: return "GTC";
      case time_in_force_e::IOC: return "IOC";
      case time_in_force_e::FOK: return "FOK";
      default: log_fatal("Unknown time_in_force_e requested to convert into str.\n"); return "Unknown time_in_force_e";
    }
  }
  static time_in_force_e fromString(const std::string& str) {
    if (str == "GTC")   return time_in_force_e::GTC;
    if (str == "IOC")   return time_in_force_e::IOC;
    if (str == "FOK")   return time_in_force_e::FOK;
    log_fatal("Unknown string requested to convert into time_in_force_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for time_in_force_e");
  }
};

/* Rate limiters (rateLimitType) */
enum class rate_limiters_e {
  REQUEST_WEIGHT,   /* { "rateLimitType": "REQUEST_WEIGHT", "interval": "MINUTE", "intervalNum": 1, "limit": 6000 } */
  ORDERS,           /* { "rateLimitType": "ORDERS", "interval": "SECOND", "intervalNum": 1, "limit": 10 } */
  RAW_REQUESTS      /* { "rateLimitType": "RAW_REQUESTS", "interval": "MINUTE", "intervalNum": 5, "limit": 61000 } */
};
template <>
struct EnumTraits<rate_limiters_e> {
  static std::string toString(rate_limiters_e value) {
    switch (value) {
      case rate_limiters_e::REQUEST_WEIGHT: return "REQUEST_WEIGHT";
      case rate_limiters_e::ORDERS:         return "ORDERS";
      case rate_limiters_e::RAW_REQUESTS:   return "RAW_REQUESTS";
      default: log_fatal("Unknown rate_limiters_e requested to convert into str.\n"); return "Unknown rate_limiters_e";
    }
  }
  static rate_limiters_e fromString(const std::string& str) {
    if (str == "REQUEST_WEIGHT")    return rate_limiters_e::REQUEST_WEIGHT;
    if (str == "ORDERS")            return rate_limiters_e::ORDERS;
    if (str == "RAW_REQUESTS")      return rate_limiters_e::RAW_REQUESTS;
    log_fatal("Unknown string requested to convert into rate_limiters_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for rate_limiters_e");
  }
};

/* Rate limit intervals (interval) */
enum class rate_limit_intervals_e {
  SECOND,
  MINUTE,
  DAY
};
template <>
struct EnumTraits<rate_limit_intervals_e> {
  static std::string toString(rate_limit_intervals_e value) {
    switch (value) {
      case rate_limit_intervals_e::SECOND:  return "SECOND";
      case rate_limit_intervals_e::MINUTE:  return "MINUTE";
      case rate_limit_intervals_e::DAY:     return "DAY";
      default: log_fatal("Unknown rate_limit_intervals_e requested to convert into str.\n"); return "Unknown rate_limit_intervals_e";
    }
  }
  static rate_limit_intervals_e fromString(const std::string& str) {
    if (str == "SECOND") return rate_limit_intervals_e::SECOND;
    if (str == "MINUTE") return rate_limit_intervals_e::MINUTE;
    if (str == "DAY") return rate_limit_intervals_e::DAY;
    log_fatal("Unknown string requested to convert into rate_limit_intervals_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for rate_limit_intervals_e");
  }
};

/* STP Modes */
enum class stp_modes_e {
  NONE,
  EXPIRE_MAKER,
  EXPIRE_TAKER,
  EXPIRE_BOTH,
  Previous
};
template <>
struct EnumTraits<stp_modes_e> {
  static std::string toString(stp_modes_e value) {
    switch (value) {
      case stp_modes_e::NONE:           return "NONE";
      case stp_modes_e::EXPIRE_MAKER:   return "EXPIRE_MAKER";
      case stp_modes_e::EXPIRE_TAKER:   return "EXPIRE_TAKER";
      case stp_modes_e::EXPIRE_BOTH:    return "EXPIRE_BOTH";
      case stp_modes_e::Previous:       return "Previous";
      default: log_fatal("Unknown stp_modes_e requested to convert into str.\n"); return "Unknown stp_modes_e";
    }
  }
  static stp_modes_e fromString(const std::string& str) {
    if (str == "NONE")          return stp_modes_e::NONE;
    if (str == "EXPIRE_MAKER")  return stp_modes_e::EXPIRE_MAKER;
    if (str == "EXPIRE_TAKER")  return stp_modes_e::EXPIRE_TAKER;
    if (str == "EXPIRE_BOTH")   return stp_modes_e::EXPIRE_BOTH;
    if (str == "Previous")      return stp_modes_e::Previous;
    log_fatal("Unknown string requested to convert into stp_modes_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for stp_modes_e");
  }
};

/* Enpoint security types */
enum class endpoint_security_type_e {
  NONE,	      /* Endpoint can be accessed freely.*/
  TRADE,	    /* Endpoint requires sending a valid API-Key and signature.*/
  USER_DATA,	/* Endpoint requires sending a valid API-Key and signature.*/
  USER_STREAM	/* Endpoint requires sending a valid API-Key.*/
};
template <>
struct EnumTraits<endpoint_security_type_e> {
  static std::string toString(endpoint_security_type_e value) {
    switch (value) {
      case endpoint_security_type_e::NONE:        return "NONE";
      case endpoint_security_type_e::TRADE:       return "TRADE";
      case endpoint_security_type_e::USER_DATA:   return "USER_DATA";
      case endpoint_security_type_e::USER_STREAM: return "USER_STREAM";
      default: log_fatal("Unknown endpoint_security_type_e requested to convert into str.\n"); return "Unknown endpoint_security_type_e";
    }
  }
  static endpoint_security_type_e fromString(const std::string& str) {
    if (str == "NONE")        return endpoint_security_type_e::NONE;
    if (str == "TRADE")       return endpoint_security_type_e::TRADE;
    if (str == "USER_DATA")   return endpoint_security_type_e::USER_DATA;
    if (str == "USER_STREAM") return endpoint_security_type_e::USER_STREAM;
    log_fatal("Unknown string requested to convert into endpoint_security_type_e: %s\n", str.c_str());
    // throw std::invalid_argument("Unknown string for endpoint_security_type_e");
  }
};

} /* namespace exchange */
} /* namespace camahjucunu */
} /* namespace cuwacunu */
```

===== FILE: exchange_types_server.h (bytes=1417, lines=36, sha256=f835417784cb649273754798f6393e221e0bd47acce35a7144936172405ec744) =====
```c
/* exchange_types_server.h */
#pragma once
#include "camahjucunu/exchange/exchange_utils.h"

namespace cuwacunu {
namespace camahjucunu {
namespace exchange {

/* --- --- --- --- --- --- --- --- --- --- --- */
/*            arguments structures             */
/* --- --- --- --- --- --- --- --- --- --- --- */
struct ping_args_t            { std::string jsonify(); };
struct time_args_t            { std::string jsonify(); };
ENFORCE_ARCHITECTURE_DESIGN(             ping_args_t);
ENFORCE_ARCHITECTURE_DESIGN(             time_args_t);


/* --- --- --- --- --- --- --- --- --- --- --- */
/*         expected return structures          */
/* --- --- --- --- --- --- --- --- --- --- --- */
struct ping_ret_t             { frame_response_t frame_rsp; ping_ret_t              (const std::string& json); };
struct time_ret_t             { frame_response_t frame_rsp; time_ret_t              (const std::string& json); long serverTime; };
ENFORCE_ARCHITECTURE_DESIGN(             ping_ret_t);
ENFORCE_ARCHITECTURE_DESIGN(             time_ret_t);


/* --- --- --- --- --- --- --- --- --- --- --- */
/*         deserialize specializations         */
/* --- --- --- --- --- --- --- --- --- --- --- */

void deserialize(ping_ret_t& deserialized, const std::string& json);
void deserialize(time_ret_t& deserialized, const std::string &json);

} /* namespace exchange */
} /* namespace camahjucunu */
} /* namespace cuwacunu */

```

===== FILE: exchange_types_trade.h (bytes=11615, lines=78, sha256=bc82f3a2250530ec3cd81107edf59c30565e57709872365cb105323c51f4e108) =====
```c
/* exchange_types_trade.h */
#pragma once
#include "camahjucunu/exchange/exchange_utils.h"

namespace cuwacunu {
namespace camahjucunu {
namespace exchange {

/* --- --- --- --- --- --- --- --- --- --- --- */
/*            arguments structures             */
/* --- --- --- --- --- --- --- --- --- --- --- */
struct orderStatus_args_t  { void add_signature(); std::string jsonify(); std::string symbol; std::optional<int> orderId = std::nullopt; std::optional<std::string> origClientOrderId = std::nullopt; std::optional<long> recvWindow; std::string apiKey; std::string signature; long timestamp; };
struct orderMarket_args_t  { void add_signature(); std::string jsonify(); std::string symbol; order_side_e side; order_type_e type; std::optional<time_in_force_e> timeInForce = std::nullopt; std::optional<double> quantity = std::nullopt; std::optional<double> quoteOrderQty = std::nullopt; std::optional<double> price = std::nullopt; std::optional<std::string> newClientOrderId = std::nullopt; std::optional<int> strategyId = std::nullopt; std::optional<int> strategyType = std::nullopt; std::optional<double> stopPrice = std::nullopt; std::optional<long> trailingDelta = std::nullopt; std::optional<double> icebergQty = std::nullopt; std::optional<order_response_type_e> newOrderRespType = std::nullopt; std::optional<stp_modes_e> selfTradePreventionMode = std::nullopt; std::optional<long> recvWindow = std::nullopt; std::string apiKey; std::string signature; long timestamp; };
ENFORCE_ARCHITECTURE_DESIGN(      orderStatus_args_t);
ENFORCE_ARCHITECTURE_DESIGN(      orderMarket_args_t);
using order_args_t        = std::variant<orderMarket_args_t>;

/* --- --- --- --- --- --- --- --- --- --- --- */
/*         expected return structures          */
/* --- --- --- --- --- --- --- --- --- --- --- */

/* secondary return structs */
struct order_fill_t        { double price; double qty; double commission; std::string commissionAsset; int tradeId; };
struct order_ack_ret_t     { frame_response_t frame_rsp; order_ack_ret_t(const std::string& json); std::string symbol; int orderId; int orderListId; std::string clientOrderId; long transactTime; };
struct order_result_ret_t  { frame_response_t frame_rsp; order_result_ret_t(); order_result_ret_t(const std::string& json); std::string symbol; int orderId; int orderListId; std::string clientOrderId; long transactTime; double origQty; double executedQty; double cummulativeQuoteQty; orderStatus_e status; time_in_force_e timeInForce; order_type_e type; order_side_e side; long workingTime; stp_modes_e selfTradePreventionMode; };
struct order_full_ret_t    { frame_response_t frame_rsp; order_full_ret_t(const std::string& json); order_result_ret_t result; std::vector<order_fill_t> fills; };
ENFORCE_ARCHITECTURE_DESIGN( order_fill_t);
ENFORCE_ARCHITECTURE_DESIGN(    order_ack_ret_t);
ENFORCE_ARCHITECTURE_DESIGN( order_result_ret_t);
ENFORCE_ARCHITECTURE_DESIGN(   order_full_ret_t);

/* primary returns */
struct orderStatus_ret_t   { frame_response_t frame_rsp; orderStatus_ret_t(); orderStatus_ret_t(const std::string& json); std::string symbol; long orderId; int orderListId; std::string clientOrderId; double price; double origQty; double executedQty; double cummulativeQuoteQty; orderStatus_e status; time_in_force_e timeInForce; order_type_e type; order_side_e side; double stopPrice; double icebergQty; long time; long updateTime; bool isWorking; long workingTime; double origQuoteOrderQty; stp_modes_e selfTradePreventionMode; int preventedMatchId; double preventedQuantity; long trailingDelta; long trailingTime; int strategyId; int strategyType; };
ENFORCE_ARCHITECTURE_DESIGN(  orderStatus_ret_t);
using orderMarket_ret_t    = std::variant<order_ack_ret_t, order_full_ret_t, order_result_ret_t>;
using order_ret_t          = std::variant<orderMarket_ret_t>;

/* --- --- --- --- --- --- --- --- --- --- --- */
/*         deserialize specializations         */
/* --- --- --- --- --- --- --- --- --- --- --- */

void deserialize(orderStatus_ret_t& deserialized, const std::string& json);
void deserialize(order_ack_ret_t& deserialized, const std::string& json);
void deserialize(order_result_ret_t& deserialized, const std::string& json);
void deserialize(order_full_ret_t& deserialized, const std::string& json);

} /* namespace exchange */
} /* namespace camahjucunu */
} /* namespace cuwacunu */

// struct orderLimit_args_t            { std::string jsonify(); std::string symbol; order_side_e side; order_type_e type; time_in_force_e timeInForce; double quantity; std::optional<double> quoteOrderQty = std::nullopt; double price; std::optional<std::string> newClientOrderId = std::nullopt; std::optional<int> strategyId = std::nullopt; std::optional<int> strategyType = std::nullopt; std::optional<double> stopPrice = std::nullopt; std::optional<long> trailingDelta = std::nullopt; std::optional<double> icebergQty = std::nullopt; std::optional<order_response_type_e> newOrderRespType = std::nullopt; std::optional<stp_modes_e> selfTradePreventionMode = std::nullopt; std::optional<long> recvWindow = std::nullopt; long timestamp; };
// struct orderStopLoss_args_t         { std::string jsonify(); std::string symbol; order_side_e side; order_type_e type; std::optional<time_in_force_e> timeInForce = std::nullopt; double quantity; std::optional<double> quoteOrderQty = std::nullopt; std::optional<double> price = std::nullopt; std::optional<std::string> newClientOrderId = std::nullopt; std::optional<int> strategyId = std::nullopt; std::optional<int> strategyType = std::nullopt; std::optional<double> stopPrice = std::nullopt; std::optional<long> trailingDelta = std::nullopt; std::optional<double> icebergQty = std::nullopt; std::optional<order_response_type_e> newOrderRespType = std::nullopt; std::optional<stp_modes_e> selfTradePreventionMode = std::nullopt; std::optional<long> recvWindow = std::nullopt; long timestamp; };
// struct orderStopLoss_limit_args_t   { std::string jsonify(); std::string symbol; order_side_e side; order_type_e type; time_in_force_e timeInForce; double quantity; std::optional<double> quoteOrderQty = std::nullopt; double price; std::optional<std::string> newClientOrderId = std::nullopt; std::optional<int> strategyId = std::nullopt; std::optional<int> strategyType = std::nullopt; double stopPrice; long trailingDelta; std::optional<double> icebergQty = std::nullopt; std::optional<order_response_type_e> newOrderRespType = std::nullopt; std::optional<stp_modes_e> selfTradePreventionMode = std::nullopt; std::optional<long> recvWindow = std::nullopt; long timestamp; };
// struct orderTakeProfit_args_t       { std::string jsonify(); std::string symbol; order_side_e side; order_type_e type; std::optional<time_in_force_e> timeInForce = std::nullopt; double quantity; std::optional<double> quoteOrderQty = std::nullopt; std::optional<double> price = std::nullopt; std::optional<std::string> newClientOrderId = std::nullopt; std::optional<int> strategyId = std::nullopt; std::optional<int> strategyType = std::nullopt; double stopPrice; long trailingDelta; std::optional<double> icebergQty = std::nullopt; std::optional<order_response_type_e> newOrderRespType = std::nullopt; std::optional<stp_modes_e> selfTradePreventionMode = std::nullopt; std::optional<long> recvWindow = std::nullopt; long timestamp; };
// struct orderTakeProfit_limit_args_t { std::string jsonify(); std::string symbol; order_side_e side; order_type_e type; time_in_force_e timeInForce; double quantity; std::optional<double> quoteOrderQty = std::nullopt; double price; std::optional<std::string> newClientOrderId = std::nullopt; std::optional<int> strategyId = std::nullopt; std::optional<int> strategyType = std::nullopt; double stopPrice; long trailingDelta; std::optional<double> icebergQty = std::nullopt; std::optional<order_response_type_e> newOrderRespType = std::nullopt; std::optional<stp_modes_e> selfTradePreventionMode = std::nullopt; std::optional<long> recvWindow = std::nullopt; long timestamp; };
// struct orderLimitMaker_args_t       { std::string jsonify(); std::string symbol; order_side_e side; order_type_e type; std::optional<time_in_force_e> timeInForce = std::nullopt; double quantity; std::optional<double> quoteOrderQty = std::nullopt; double price; std::optional<std::string> newClientOrderId = std::nullopt; std::optional<int> strategyId = std::nullopt; std::optional<int> strategyType = std::nullopt; std::optional<double> stopPrice = std::nullopt; std::optional<long> trailingDelta = std::nullopt; std::optional<double> icebergQty = std::nullopt; std::optional<order_response_type_e> newOrderRespType = std::nullopt; std::optional<stp_modes_e> selfTradePreventionMode = std::nullopt; std::optional<long> recvWindow = std::nullopt; long timestamp; };
// struct orderSor_args_t              { std::string jsonify(); std::string symbol; order_side_e side; order_type_e type; std::optional<time_in_force_e> timeInForce = std::nullopt; std::optional<double> quantity = std::nullopt; std::optional<double> price = std::nullopt; std::optional<std::string> newClientOrderId = std::nullopt; std::optional<int> strategyId = std::nullopt; std::optional<int> strategyType = std::nullopt; std::optional<double> icebergQty = std::nullopt; std::optional<order_response_type_e> newOrderRespType = std::nullopt; std::optional<stp_modes_e> selfTradePreventionMode = std::nullopt; std::optional<long> recvWindow = std::nullopt; long timestamp; };
// using order_args_t                  = std::variant<orderLimit_args_t, orderMarket_args_t, orderStopLoss_args_t, orderStopLoss_limit_args_t, orderTakeProfit_args_t, orderTakeProfit_limit_args_t, orderLimitMaker_args_t, orderSor_args_t>;
// ENFORCE_ARCHITECTURE_DESIGN(             orderLimit_args_t);
// ENFORCE_ARCHITECTURE_DESIGN(         orderStopLoss_args_t);
// ENFORCE_ARCHITECTURE_DESIGN(   orderStopLoss_limit_args_t);
// ENFORCE_ARCHITECTURE_DESIGN(       orderTakeProfit_args_t);
// ENFORCE_ARCHITECTURE_DESIGN( orderTakeProfit_limit_args_t);
// ENFORCE_ARCHITECTURE_DESIGN(       orderLimitMaker_args_t);
// ENFORCE_ARCHITECTURE_DESIGN(               orderSor_args_t);

// struct orderSor_fill_t      { orderSor_fill_t(); orderSor_fill_t(const std::string& json); std::string matchType; double price; double qty; double commission; std::string commissionAsset; int tradeId; int allocId; };
// struct orderSor_full_ret_t { orderSor_full_ret_t(const std::string& json); order_result_ret_t result; double price; allocation_type_e workingFloor; bool usedSor; std::vector<orderSor_fill_t> fills; };
// ENFORCE_ARCHITECTURE_DESIGN(      orderSor_fill_t);
// ENFORCE_ARCHITECTURE_DESIGN( orderSor_full_ret_t);
// using orderLimit_ret_t             = std::variant<order_ack_ret_t, order_result_ret_t, order_full_ret_t>;
// using orderStopLoss_ret_t         = std::variant<order_ack_ret_t, order_result_ret_t, order_full_ret_t>;
// using orderStopLoss_limit_ret_t   = std::variant<order_ack_ret_t, order_result_ret_t, order_full_ret_t>;
// using orderTakeProfit_ret_t       = std::variant<order_ack_ret_t, order_result_ret_t, order_full_ret_t>;
// using orderTakeProfit_limit_ret_t = std::variant<order_ack_ret_t, order_result_ret_t, order_full_ret_t>;
// using orderLimitMaker_ret_t       = std::variant<order_ack_ret_t, order_result_ret_t, order_full_ret_t>;
// using orderSor_ret_t               = std::variant<orderSor_full_ret_t>;
// using order_ret_t                   = std::variant<orderLimit_ret_t, orderMarket_ret_t, orderStopLoss_ret_t, orderStopLoss_limit_ret_t, orderTakeProfit_ret_t, orderTakeProfit_limit_ret_t, orderLimitMaker_ret_t, orderSor_ret_t>;

```

===== FILE: exchange_utils.h (bytes=15406, lines=403, sha256=0774b5be1afa0bb9b9ffdc33bf57a1c2d70e3d8591d175bf1e38ebcd542fdedb) =====
```c
/* exchange_utils.h */
#pragma once
#include <tuple>
#include <vector>
#include <variant>
#include <optional>
#include <sstream>
#include <fstream>
#include <type_traits>
#include "piaabo/dutils.h"
#include "piaabo/dsecurity.h"
#include "piaabo/djson_parsing.h"
#include "piaabo/darchitecture.h"
#include "camahjucunu/exchange/exchange_types_enums.h"

#define DOUBLE_SERIALIZATION_PRECISION 8
#define QUOTE_DOUBLES /* decimal numbers are required by exchange to be serialized as strings */
#undef QUOTE_DOUBLES_SIGNATURE /* decimal numbers are required by exchange to be signed as strings */

namespace cuwacunu {
namespace camahjucunu {
namespace exchange {

/* --- --- --- --- --- --- --- --- --- --- --- */
/*         exchange global structs             */
/* --- --- --- --- --- --- --- --- --- --- --- */

struct frame_response_t { uint http_status; std::string frame_id; };
ENFORCE_ARCHITECTURE_DESIGN(frame_response_t);

struct loaded_data_response_t { std::map<interval_type_e, std::vector<double>> data; };
ENFORCE_ARCHITECTURE_DESIGN(loaded_data_response_t);

/* --- --- --- --- --- --- --- --- --- --- --- */
/*         serialization utils                 */
/* --- --- --- --- --- --- --- --- --- --- --- */

int64_t getUnixTimestampMillis();

template<typename T>
struct is_std_optional : std::false_type {};

template<typename T>
struct is_std_optional<std::optional<T>> : std::true_type {};

template<typename T>
inline constexpr bool is_std_optional_v = is_std_optional<T>::value;

/* --- --- --- --- --- --- --- --- --- --- --- */
/*        strcut to string functions           */
/* --- --- --- --- --- --- --- --- --- --- --- */
/* Specialization for bool and std::optional<bool> */
template<typename T>
typename std::enable_if<std::is_same<T, bool>::value || std::is_same<T, std::optional<bool>>::value, std::string>::type
serialize(const cuwacunu::piaabo::dPair<const std::string, T>& arg) {
  std::ostringstream oss;
  if constexpr (is_std_optional_v<T>) {
    if (arg.second.has_value()) {
      oss << "\"" << arg.first << "\":" << (arg.second.value() ? "true," : "false,");
    }
  } else {
    oss << "\"" << arg.first << "\":" << (arg.second ? "true," : "false,");
  }
  return oss.str();
}

/* Specialization for int and std::optional<int> */
template<typename T>
typename std::enable_if<(std::is_same<T, int>::value || std::is_same<T, std::optional<int>>::value) || (std::is_same<T, long>::value || std::is_same<T, std::optional<long>>::value), std::string>::type
serialize(const cuwacunu::piaabo::dPair<const std::string, T>& arg) {
  std::ostringstream oss;
  oss << std::fixed;
  if constexpr (is_std_optional_v<T>) {
    if (arg.second.has_value()) {
      oss << "\"" << arg.first << "\":" << arg.second.value() << ",";
    }
  } else {
    oss << "\"" << arg.first << "\":" << arg.second << ",";
  }
  return oss.str();
}

/* Specialization for double and std::optional<double> */
template<typename T>
typename std::enable_if<std::is_same<T, double>::value || std::is_same<T, std::optional<double>>::value, std::string>::type
serialize(const cuwacunu::piaabo::dPair<const std::string, T>& arg) {
  std::ostringstream oss;
  oss.precision(DOUBLE_SERIALIZATION_PRECISION);
  oss << std::fixed;
#ifdef QUOTE_DOUBLES
  if constexpr (is_std_optional_v<T>) {
    if (arg.second.has_value()) {
      oss << "\"" << arg.first << "\":" << "\"" << arg.second.value() << "\"" << ",";
    }
  } else {
    oss << "\"" << arg.first << "\":" << "\"" << arg.second << "\"" << ",";
  }
#else
  /* disable quoting doubles in serialization */
  if constexpr (is_std_optional_v<T>) {
    if (arg.second.has_value()) {
      oss << "\"" << arg.first << "\":" << arg.second.value() << ",";
    }
  } else {
    oss << "\"" << arg.first << "\":" << arg.second << ",";
  }
#endif
  return oss.str();
}

/* Specialization for strings and std::optional<string> */
template<typename T>
typename std::enable_if<std::is_same<T, std::string>::value || std::is_same<T, std::optional<std::string>>::value, std::string>::type
serialize(const cuwacunu::piaabo::dPair<const std::string, T>& arg) {
  std::ostringstream oss;
  if constexpr (is_std_optional_v<T>) {
    if (arg.second.has_value()) {
      oss << "\"" << arg.first << "\":\"" << arg.second.value() << "\",";
    }
  } else {
    oss << "\"" << arg.first << "\":\"" << arg.second << "\",";
  }
  return oss.str();
}

/* Specialization for any enum type and std::optional<enum> */
template<typename T>
typename std::enable_if<std::is_enum<T>::value || is_optional_enum<T>::value, std::string>::type
serialize(const cuwacunu::piaabo::dPair<const std::string, T>& arg) {
  std::ostringstream oss;
  if constexpr (is_std_optional_v<T>) {
    if (arg.second.has_value()) {
      oss << "\"" << arg.first << "\":\"" << enum_to_string(arg.second.value()) << "\",";
    }
  } else {
    oss << "\"" << arg.first << "\":\"" << enum_to_string(arg.second) << "\",";
  }
  return oss.str();
}

/* Specialization for std::variant<std::string, std::vector<std::string>> */
template<typename T>
typename std::enable_if<std::is_same<T, std::variant<std::string, std::vector<std::string>>>::value, std::string>::type
serialize(const cuwacunu::piaabo::dPair<const std::string, T>& arg) {
  std::ostringstream oss;
  oss << "\"" << arg.first << "\":";

  std::visit([&oss](const auto& value) {  // Correctly name and reference the value
    using ValueType = std::decay_t<decltype(value)>;  // Determine the type of the visited value
    if constexpr (std::is_same_v<ValueType, std::string>) {
      oss << "\"" << value << "\"";  // Correctly format the string
    } else if constexpr (std::is_same_v<ValueType, std::vector<std::string>>) {
      oss << "[";
      for (size_t i = 0; i < value.size(); ++i) {
        oss << "\"" << value[i] << "\"";  // Serialize each string in the vector
        if (i < value.size() - 1) oss << ", ";  // Add commas between elements
      }
      oss << "]";
    }
  }, arg.second);

  oss << ",";
  return oss.str();
}


/* --- --- --- --- --- --- --- --- --- --- --- */
/*        strcut fields signature functions    */
/* --- --- --- --- --- --- --- --- --- --- --- */
/* Specialization for bool and std::optional<bool> */
template<typename T>
typename std::enable_if<std::is_same<T, bool>::value || std::is_same<T, std::optional<bool>>::value, std::string>::type
field_signature(const cuwacunu::piaabo::dPair<const std::string, T>& arg) {
  std::ostringstream oss;
  if constexpr (is_std_optional_v<T>) {
    if (arg.second.has_value()) {
      oss << "&" << arg.first << "=" << (arg.second.value() ? "true" : "false");
    }
  } else {
    oss << "&" << arg.first << "=" << (arg.second ? "true" : "false");
  }
  return oss.str();
}

/* Specialization for int and std::optional<int> */
template<typename T>
typename std::enable_if<(std::is_same<T, int>::value || std::is_same<T, std::optional<int>>::value) || (std::is_same<T, long>::value || std::is_same<T, std::optional<long>>::value), std::string>::type
field_signature(const cuwacunu::piaabo::dPair<const std::string, T>& arg) {
  std::ostringstream oss;
  oss << std::fixed;
  if constexpr (is_std_optional_v<T>) {
    if (arg.second.has_value()) {
      oss << "&" << arg.first << "=" << arg.second.value();
    }
  } else {
    oss << "&" << arg.first << "=" << arg.second;
  }
  return oss.str();
}

/* Specialization for double and std::optional<double> */
template<typename T>
typename std::enable_if<std::is_same<T, double>::value || std::is_same<T, std::optional<double>>::value, std::string>::type
field_signature(const cuwacunu::piaabo::dPair<const std::string, T>& arg) {
  std::ostringstream oss;
  oss.precision(DOUBLE_SERIALIZATION_PRECISION);
  oss << std::fixed;
#ifdef QUOTE_DOUBLES_SIGNATURE
  if constexpr (is_std_optional_v<T>) {
    if (arg.second.has_value()) {
      oss << "&" << arg.first << "=" << arg.second.value();
    }
  } else {
    oss << "&" << arg.first << "=" << arg.second;
  }
#else 
  /* disable quoting doubles in serialization */
  if constexpr (is_std_optional_v<T>) {
    if (arg.second.has_value()) {
      oss << "&" << arg.first << "=" << arg.second.value();
    }
  } else {
    oss << "&" << arg.first << "=" << arg.second;
  }
#endif
  return oss.str();
}

/* Specialization for strings and std::optional<string> */
template<typename T>
typename std::enable_if<std::is_same<T, std::string>::value || std::is_same<T, std::optional<std::string>>::value, std::string>::type
field_signature(const cuwacunu::piaabo::dPair<const std::string, T>& arg) {
  std::ostringstream oss;
  if constexpr (is_std_optional_v<T>) {
    if (arg.second.has_value()) {
      oss << "&" << arg.first << "=" << arg.second.value();
    }
  } else {
    oss << "&" << arg.first << "=" << arg.second;
  }
  return oss.str();
}

/* Specialization for any enum type and std::optional<enum> */
template<typename T>
typename std::enable_if<std::is_enum<T>::value || is_optional_enum<T>::value, std::string>::type
field_signature(const cuwacunu::piaabo::dPair<const std::string, T>& arg) {
  std::ostringstream oss;
  if constexpr (is_std_optional_v<T>) {
    if (arg.second.has_value()) {
      oss << "&" << arg.first << "=" << enum_to_string(arg.second.value());
    }
  } else {
    oss << "&" << arg.first << "=" << enum_to_string(arg.second);
  }
  return oss.str();
}

/* Specialization for std::variant<std::string, std::vector<std::string>> */
template<typename T>
typename std::enable_if<std::is_same<T, std::variant<std::string, std::vector<std::string>>>::value, std::string>::type
field_signature(const cuwacunu::piaabo::dPair<const std::string, T>& arg) {
  std::ostringstream oss;
  oss << "&" << arg.first << "=";

  std::visit([&oss](const auto& value) {  // Correctly name and reference the value
    using ValueType = std::decay_t<decltype(value)>;  // Determine the type of the visited value
    if constexpr (std::is_same_v<ValueType, std::string>) {
      oss << value;  // Correctly format the string
    } else if constexpr (std::is_same_v<ValueType, std::vector<std::string>>) {
      oss << "[";
      for (size_t i = 0; i < value.size(); ++i) {
        oss << value[i];  // Serialize each string in the vector
        if (i < value.size() - 1) oss << ",";  // Add commas between elements
      }
      oss << "]";
    }
  }, arg.second);

  return oss.str();
}


/* --- --- --- --- --- --- --- --- --- --- --- */
/*        auxiliary functions                  */
/* --- --- --- --- --- --- --- --- --- --- --- */

/* Clean json for finalization */
void finalize_signature(std::string& signature);

/* Clean json for finalization */
void finalize_json(std::string& json);

/*Variadic template to handle multiple arguments */
template<typename... Args>
std::string jsonify_as_object(Args... args) {
  std::ostringstream oss;
  (oss << ... << serialize(args)); /* Fold expression over the comma operator */
  std::string ret_val = "{" + oss.str() + "}";
  finalize_json(ret_val);
  return ret_val;
}

/*Variadic template to handle multiple arguments */
template<typename... Args>
std::string jsonify_as_array(Args... args) {
  std::ostringstream oss;
  (oss << ... << serialize(args)); /* Fold expression over the comma operator */
  std::string ret_val = "[" + oss.str() + "]";
  finalize_json(ret_val);
  return ret_val;
}

} /* namespace exchange */
} /* namespace camahjucunu */
} /* namespace cuwacunu */

#define pairWrap(variable) cuwacunu::piaabo::dPair<const std::string, decltype(variable)>{#variable, variable}
#define pairWrap_variant(variable) cuwacunu::piaabo::dPair<const std::string, decltype(variable)>{std::holds_alternative<std::vector<std::string>>(variable) ? #variable"s" : "symbol" , variable}

/* Define macros for accessing these types within a std::variant */
#define GET_OBJECT(obj, obj_type) (std::get<obj_type>(obj))
#define GET_VECT_OBJECT(obj, obj_type) (std::get<std::vector<obj_type>>(obj))

#define GET_TICK_FULL(obj) (std::get<cuwacunu::camahjucunu::exchange::tick_full_t>(obj.ticks))
#define GET_TICK_MINI(obj) (std::get<cuwacunu::camahjucunu::exchange::tick_mini_t>(obj.ticks))

#define GET_VECT_TICK_FULL(obj) (std::get<std::vector<cuwacunu::camahjucunu::exchange::tick_full_t>>(obj.ticks))
#define GET_VECT_TICK_MINI(obj) (std::get<std::vector<cuwacunu::camahjucunu::exchange::tick_mini_t>>(obj.ticks))

/* ------------------- General ------------------- */
#define INITIAL_PARSE(json_input, root_var, obj_var) \
    cuwacunu::piaabo::JsonValue root_var = \
        cuwacunu::piaabo::JsonParser(json_input).parse(); \
    cuwacunu::piaabo::ObjectType& obj_var = *(root_var.objectValue)

#define RETRIVE_OBJECT(obj_var, key, result_obj) \
  cuwacunu::piaabo::ObjectType& result_obj = *(obj_var[key].objectValue)

#define RETRIVE_ARRAY(obj_var, key, result_arr) \
  cuwacunu::piaabo::ArrayType& result_arr = *(obj_var[key].arrayValue)

#define RETRIVE_OBJECT_FROM_OBJECT(obj_var, key, result_obj) \
  RETRIVE_OBJECT((*obj_var.objectValue), key, result_obj)

/* ------------------- Value - Keys ------------------- */

#define ASSIGN_STRING_FIELD_FROM_JSON_STRING(obj, root_obj, json_key, member) \
  obj.member = root_obj[json_key].stringValue;

#define ASSIGN_DOUBLE_FIELD_FROM_JSON_STRING(obj, root_obj, json_key, member) \
  do { \
    try { \
      obj.member = std::stod(root_obj[json_key].stringValue.c_str()); \
    } catch (...) { } \
  } while (false)

#define ASSIGN_NUMBER_FIELD_FROM_JSON_NUMBER(obj, root_obj, json_key, member, cast_type) \
  obj.member = static_cast<cast_type>(root_obj[json_key].numberValue);

#define ASSIGN_BOOL_FIELD_FROM_JSON_BOOL(obj, root_obj, json_key, member) \
  obj.member = root_obj[json_key].boolValue;

#define ASSIGN_ENUM_FIELD_FROM_JSON_STRING(obj, root_obj, json_key, member, T) \
  do { \
    try { \
      obj.member = string_to_enum<T>(root_obj[json_key].stringValue); \
    } catch (...) {} \
  } while (false)

/* ------------------- Values From Object ------------------- */

#define ASSIGN_NUMBER_FIELD_FROM_JSON_NUMBER_IN_OBJECT(obj, root_obj, json_key, member, cast_type) \
  ASSIGN_NUMBER_FIELD_FROM_JSON_NUMBER(obj, (*root_obj.objectValue), json_key, member, cast_type)

#define ASSIGN_STRING_FIELD_FROM_JSON_STRING_IN_OBJECT(obj, root_obj, json_key, member) \
  ASSIGN_STRING_FIELD_FROM_JSON_STRING(obj, (*root_obj.objectValue), json_key, member)

#define ASSIGN_DOUBLE_FIELD_FROM_JSON_STRING_IN_OBJECT(obj, root_obj, json_key, member) \
  ASSIGN_DOUBLE_FIELD_FROM_JSON_STRING(obj, (*root_obj.objectValue), json_key, member)

#define ASSIGN_BOOL_FIELD_FROM_JSON_BOOL_IN_OBJECT(obj, root_obj, json_key, member) \
  ASSIGN_BOOL_FIELD_FROM_JSON_BOOL(obj, (*root_obj.objectValue), json_key, member)

#define ASSIGN_ENUM_FIELD_FROM_JSON_STRING_IN_OBJECT(obj, root_obj, json_key, member, T) \
  ASSIGN_ENUM_FIELD_FROM_JSON_STRING(obj, (*root_obj.objectValue), json_key, member, T)

/* ------------------- Values From Array ------------------- */

#define ASSIGN_NUMBER_FIELD_FROM_JSON_NUMBER_IN_ARRAY(obj, root_arr, index, member, cast_type) \
  obj.member = static_cast<cast_type>((*root_arr.arrayValue)[index].numberValue);

#define ASSIGN_DOUBLE_FIELD_FROM_JSON_STRING_IN_ARRAY(obj, root_arr, index, member) \
  do { \
    try { \
      obj.member = std::stod((*root_arr.arrayValue)[index].stringValue.c_str()); \
    } catch (...) {} \
  } while (false)

#define ALLOCATE_VECT(obj, size) \
  obj.reserve(size); \
  obj.clear();


```

### Root summary: files_included=17, skipped_non_text=1

---
Included files (total): 16
Skipped non-text (total): 1
Total bytes written: 93081
Done.
