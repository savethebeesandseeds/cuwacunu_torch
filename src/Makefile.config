# =============================================================================
# Makefile.config — project-wide build configuration & reusable rules (TESTS)
#
# This file is included by test Makefiles under /tests/bench/... only.
# It provides:
#   • toolchain flags, include paths, linker libs
#   • reliable .d dependency tracking
#   • tiny leaf Makefiles (use TEST_ONEFILE)
#   • per-module static archives (reused by tests)
#   • a dispatcher helper that builds first, then runs
# =============================================================================

# -----------------------------------------------------------------------------
# 0) Toolchain & Core Flags
# -----------------------------------------------------------------------------
CXX          := g++
CXX_STANDARD := c++20

COMMON_WARN  := -Wall -Wno-unused-function
DEBUG_FLAGS  := -g -Og -fno-omit-frame-pointer -rdynamic

# Compile-time hardening (objects)
SEC_CFLAGS   := -fstack-protector-strong -D_FORTIFY_SOURCE=2 -fPIC
# Link-time hardening (executables)
SEC_LDFLAGS  := -pie -fPIE

CXXFLAGS     += -std=$(CXX_STANDARD) $(COMMON_WARN) $(DEBUG_FLAGS) $(SEC_CFLAGS)
LDFLAGS      += $(SEC_LDFLAGS)

# -----------------------------------------------------------------------------
# 0.A) FAST_BUILD profile (fast by default; safe opt-out)
# -----------------------------------------------------------------------------
# Usage:
#   make ...                    # FAST_BUILD=1 by default
#   FAST_BUILD=0 make ...       # explicit legacy fallback
# Optional knobs:
#   FAST_CCACHE=auto|on|off
#   FAST_LINKER=auto|mold|lld|system
#   SECURE_LOCAL_CLEAN=0|1      (default: 1)
#   HASH_ARTIFACT_LOG=0|1       (default: 1)
FAST_BUILD ?= 1
FAST_BUILD_ON := $(filter 1 yes true on,$(strip $(FAST_BUILD)))

FAST_CCACHE ?= auto
FAST_LINKER ?= mold

# Keep project identity defaults unless explicitly overridden.
SECURE_LOCAL_CLEAN ?= 1
HASH_ARTIFACT_LOG ?= 1

# In fast mode, enable parallel build by default unless caller already set it.
ifeq ($(FAST_BUILD_ON),1)
  PARALLEL_BUILD ?= 1
endif

# -----------------------------------------------------------------------------
# 0.1) SHOW_CMD toggle
# -----------------------------------------------------------------------------
SHOW_CMD ?= 0
SHOW_CMD_ON := $(filter 1 yes true on,$(strip $(SHOW_CMD)))
Q := $(if $(SHOW_CMD_ON),,@)

ifeq ($(SHOW_CMD_ON),)
  MAKEFLAGS += --no-builtin-rules --no-print-directory -s
else
  MAKEFLAGS += --no-builtin-rules --no-print-directory
endif

# Propagate the toggle to any sub-makes (important for the dispatcher)
MAKEFLAGS += SHOW_CMD=$(SHOW_CMD)

# -----------------------------------------------------------------------------
# 0.2) Optional parallel build control
# -----------------------------------------------------------------------------
# Usage:
#   PARALLEL_BUILD=1 make ...
#   PARALLEL_BUILD=1 PARALLEL_JOBS=9 make ...
# Defaults:
#   - off (preserves current behavior unless explicitly enabled)
#   - if PARALLEL_JOBS=0 and PARALLEL_BUILD=1, use detected CPU count
PARALLEL_BUILD ?= 0
PARALLEL_BUILD_ON := $(filter 1 yes true on,$(strip $(PARALLEL_BUILD)))
PARALLEL_JOBS ?= 0

ifeq ($(PARALLEL_BUILD_ON),1)
  # Only top-level make invocation injects -j.
  # Recursive sub-makes should inherit and honor the jobserver.
  ifeq ($(MAKELEVEL),0)
    ifeq ($(strip $(PARALLEL_JOBS)),0)
      PARALLEL_JOBS := $(strip $(shell nproc 2>/dev/null || getconf _NPROCESSORS_ONLN 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo 1))
    endif
    # Avoid duplicating explicit -j flags from command line.
    ifeq ($(filter -j% --jobs%,$(MAKEFLAGS)),)
      MAKEFLAGS += -j$(PARALLEL_JOBS)
    endif
  endif
endif

# -----------------------------------------------------------------------------
# 0.3) Optional toolchain acceleration (safe fallback)
# -----------------------------------------------------------------------------
CXX_BASE ?= $(CXX)
CCACHE_DIR ?= /tmp/.ccache-cuwacunu
CCACHE_ENV = CCACHE_DIR=$(CCACHE_DIR)

CCACHE_BIN := $(strip $(shell command -v ccache 2>/dev/null))
USE_CCACHE := 0
ifeq ($(FAST_BUILD_ON),1)
  ifneq ($(filter off,$(strip $(FAST_CCACHE))),off)
    ifneq ($(CCACHE_BIN),)
      USE_CCACHE := 1
    endif
  endif
endif

LD_MOLD := $(strip $(shell command -v ld.mold 2>/dev/null || command -v mold 2>/dev/null))
LD_LLD  := $(strip $(shell command -v ld.lld 2>/dev/null || command -v lld 2>/dev/null))

FAST_LINKER_EFFECTIVE := system
ifeq ($(FAST_BUILD_ON),1)
  ifeq ($(strip $(FAST_LINKER)),auto)
    ifneq ($(LD_MOLD),)
      FAST_LINKER_EFFECTIVE := mold
    else ifneq ($(LD_LLD),)
      FAST_LINKER_EFFECTIVE := lld
    endif
  else
    FAST_LINKER_EFFECTIVE := $(strip $(FAST_LINKER))
  endif

  # Forced values degrade gracefully to system linker when unavailable.
  ifeq ($(FAST_LINKER_EFFECTIVE),mold)
    ifeq ($(LD_MOLD),)
      FAST_LINKER_EFFECTIVE := system
    endif
  endif
  ifeq ($(FAST_LINKER_EFFECTIVE),lld)
    ifeq ($(LD_LLD),)
      FAST_LINKER_EFFECTIVE := system
    endif
  endif
endif

LDFLAGS_FUSE :=
ifeq ($(FAST_BUILD_ON),1)
  ifeq ($(FAST_LINKER_EFFECTIVE),mold)
    LDFLAGS_FUSE := -fuse-ld=mold
  else ifeq ($(FAST_LINKER_EFFECTIVE),lld)
    LDFLAGS_FUSE := -fuse-ld=lld
  endif
endif

CXX_COMPILE = $(strip $(if $(filter 1,$(USE_CCACHE)),$(CCACHE_BIN),) $(CXX_BASE))
CXX_LINK    = $(CXX_BASE)
LDFLAGS_E   = $(LDFLAGS) $(LDFLAGS_FUSE)

ifeq ($(MAKELEVEL),0)
  $(info [BUILD_MODE] FAST_BUILD=$(if $(FAST_BUILD_ON),1,0) PARALLEL_BUILD=$(PARALLEL_BUILD) ccache=$(if $(filter 1,$(USE_CCACHE)),on,off) ccache_dir=$(CCACHE_DIR) linker=$(FAST_LINKER_EFFECTIVE) secure_clean=$(SECURE_LOCAL_CLEAN) hash_log=$(HASH_ARTIFACT_LOG))
endif

# -----------------------------------------------------------------------------
# 1) Project Layout
# -----------------------------------------------------------------------------
OUTPUT_PATH := $(ROOT_PATH)/build
IMPL_PATH   := $(ROOT_PATH)/impl
CONFIG_PATH := $(ROOT_PATH)/config
TESTS_PATH  := $(ROOT_PATH)/tests

# Absolute path (avoids // and mismatched -C sub-makes)
TESTS_PATH_ABS := $(abspath $(TESTS_PATH))
TEST_OUT       := $(patsubst %/,%,$(TESTS_PATH_ABS)/build)

# Build the whole impl tree (used by AUTO_PREP)
.PHONY: modules
modules:
	$(Q)+$(MAKE) -C $(IMPL_PATH) all

# -----------------------------------------------------------------------------
# 2) External SDK Locations
# -----------------------------------------------------------------------------
EXTERNAL_LIBS_PATH := /cuwacunu/external
LIBTORCH_PATH      := $(EXTERNAL_LIBS_PATH)/libtorch
LIBCUDA_PATH       := /usr/local/cuda-12.1
SSL_PATH           := /usr
SYSTEM_CURL_PATH   := /usr
LIBCURL_PATH       ?= $(EXTERNAL_LIBS_PATH)/curl-8.9.1

ifneq ($(wildcard $(LIBCURL_PATH)/include/curl/curl.h),)
  LIBCURL_INCLUDE_ROOT := $(LIBCURL_PATH)/include
else
  LIBCURL_INCLUDE_ROOT := $(SYSTEM_CURL_PATH)/include
endif

ifneq ($(wildcard $(LIBCURL_PATH)/lib/.libs/libcurl.so),)
  LIBCURL_LIB_PATH := $(LIBCURL_PATH)/lib/.libs
else ifneq ($(wildcard $(LIBCURL_PATH)/lib/.libs/libcurl.a),)
  LIBCURL_LIB_PATH := $(LIBCURL_PATH)/lib/.libs
else
  LIBCURL_LIB_PATH := $(SYSTEM_CURL_PATH)/lib/x86_64-linux-gnu
endif

# -----------------------------------------------------------------------------
# 3) Include Paths
# -----------------------------------------------------------------------------
USUAL_INCLUDE_PATHS   := -I$(ROOT_PATH)/ -I$(ROOT_PATH)/include -I$(ROOT_PATH)/include/torch_compat
TORCH_INCLUDE_PATHS   := -I$(LIBTORCH_PATH)/include -I$(LIBTORCH_PATH)/include/torch/csrc/api/include -I$(LIBCUDA_PATH)/include
SSL_INCLUDE_PATHS     := -I$(SSL_PATH)/include
LIBCURL_INCLUDE_PATHS := -I$(LIBCURL_INCLUDE_ROOT)
NCURSES_INCLUDE_PATHS := -I/usr/include/ncursesw

# -----------------------------------------------------------------------------
# 4) Link Libraries (system libs)
# -----------------------------------------------------------------------------
# NOTE: g++ links libstdc++ automatically; we keep -lstdc++ for clarity.
LDLIBS_common := -lstdc++ -lpthread -lm

LDLIBS_torch := -L$(LIBTORCH_PATH)/lib -L$(LIBCUDA_PATH)/lib64
LDLIBS_torch += -Wl,-rpath,$(LIBTORCH_PATH)/lib
LDLIBS_torch += -Wl,-rpath,$(LIBCUDA_PATH)/lib64
LDLIBS_torch += -ltorch_cuda -lc10_cuda -ltorch_cpu -ltorch -lcudnn -lc10
LDLIBS_torch += -lcuda -lcudart -lnvToolsExt

LDLIBS_ssl  := -L$(SSL_PATH)/lib/x86_64-linux-gnu/ -lcrypto -lssl
LDLIBS_curl := -L$(LIBCURL_LIB_PATH) -Wl,-rpath,$(LIBCURL_LIB_PATH) -lcurl

# Keep original naming for ncurses compatibility across the tests tree
LDLIBS_ncurses := -lncursesw
# If your distro needs it, uncomment:
# LDLIBS_ncurses := -lncursesw -ltinfo

# -----------------------------------------------------------------------------
# 5) Dependency (.d) Files
# -----------------------------------------------------------------------------
DEPDIR := $(OUTPUT_PATH)/.deps
OBJTMP := $(OUTPUT_PATH)/.objs

# Object rules (CC_RULE) write depfiles alongside $(OUTPUT_PATH) tree
DEPFILE  = $(DEPDIR)/$(@:$(OUTPUT_PATH)/%=%:.o=.d)
DEPFLAGS = -MMD -MP -MF $(DEPFILE) -MT $@

# Include all known depfiles (safe if none exist yet)
-include $(shell test -d $(DEPDIR) && find $(DEPDIR) -name '*.d' -print)

# -----------------------------------------------------------------------------
# 6) Logging (with runtime SHA-256)
# -----------------------------------------------------------------------------
COLOR_GREEN      := \033[32m
COLOR_DIM_GREEN  := \033[2;32m
COLOR_YELLOW     := \033[33m
COLOR_DIM_YELLOW := \033[2;33m
COLOR_RED        := \033[31m
COLOR_GRAY       := \033[90m
COLOR_RESET      := \033[0m

LOG_START = { \
  printf "$(COLOR_DIM_YELLOW)[$(COLOR_GRAY)OBJ:$(COLOR_DIM_YELLOW)BUILD]$(COLOR_RESET)  \
$(COLOR_GRAY)%-70s request to build.$(COLOR_RESET)\n" "$(notdir $@)"; \
}

HASH_ARTIFACT_LOG_ON := $(filter 1 yes true on,$(strip $(HASH_ARTIFACT_LOG)))
ifeq ($(HASH_ARTIFACT_LOG_ON),1)
LOG_END = { \
  sha="$$(sha256sum '$@' 2>/dev/null | awk '{print $$1}')"; \
  md5="$$(md5sum    '$@' 2>/dev/null | awk '{print $$1}')"; \
  printf "$(COLOR_DIM_YELLOW)[$(COLOR_GRAY)OBJ:$(COLOR_DIM_GREEN)   OK$(COLOR_DIM_YELLOW)]$(COLOR_RESET)  \
$(COLOR_GRAY)%-70s $(COLOR_GRAY)[$(COLOR_DIM_YELLOW)sha256:$(COLOR_GRAY)%s][$(COLOR_DIM_YELLOW)md5:$(COLOR_GRAY)%s]$(COLOR_RESET)\n" "$(notdir $@)" "$$sha" "$$md5"; \
} || printf "$(COLOR_DIM_YELLOW)    [OBJ:$(COLOR_RED)FAIL$(COLOR_DIM_YELLOW) ]$(COLOR_RESET)  %-20s (exit %s)\n" \
       "$(notdir $@)" "$$?"
else
LOG_END = { \
  printf "$(COLOR_DIM_YELLOW)[$(COLOR_GRAY)OBJ:$(COLOR_DIM_GREEN)   OK$(COLOR_DIM_YELLOW)]$(COLOR_RESET)  \
$(COLOR_GRAY)%-70s$(COLOR_RESET)\n" "$(notdir $@)"; \
} || printf "$(COLOR_DIM_YELLOW)    [OBJ:$(COLOR_RED)FAIL$(COLOR_DIM_YELLOW) ]$(COLOR_RESET)  %-20s (exit %s)\n" \
       "$(notdir $@)" "$$?"
endif

# Remove stale output before re-creating (defends against stray files)
SECURE_LOCAL_CLEAN_ON := $(filter 1 yes true on,$(strip $(SECURE_LOCAL_CLEAN)))
ifeq ($(SECURE_LOCAL_CLEAN_ON),1)
LOCAL_CLEAN = { [ -f $@ ] && shred -u $@ || true; }
else
LOCAL_CLEAN = { rm -f $@ || true; }
endif

# Optional run modes (tests may override RUN_MODE)
PLAIN     :=
GDB       := gdb -ex "set print thread-events off" -ex run
GDB_TORCH := CUDA_LAUNCH_BLOCKING=1 TORCH_SHOW_CPP_STACKTRACES=1 $(GDB)
VALGRIND  := valgrind --leak-check=full -s --show-leak-kinds=all \
               --suppressions=$(CONFIG_PATH)/valgrind.supp \
               --gen-suppressions=all \
               --log-file=$(ROOT_PATH)/src/valgrind.log
RUN_MODE  = $(PLAIN)

# -----------------------------------------------------------------------------
# 7) Central Build Rules (split lines so g++ shows clearly)
# -----------------------------------------------------------------------------
define CC_RULE
	$(Q)mkdir -p $(@D) $(DEPDIR) $(dir $(DEPFILE)) $(if $(filter 1,$(USE_CCACHE)),$(CCACHE_DIR),)
	$(Q)$(LOG_START)
	$(Q)$(LOCAL_CLEAN)
	$(Q)$(CCACHE_ENV) $(CXX_COMPILE) $(CXXFLAGS) $(DEPFLAGS) \
	      $(USUAL_INCLUDE_PATHS) $(INCLUDES_EXTRA) \
	      -c $< -o $@
	$(Q)$(LOG_END)
endef

define ONEFILE_EXE_RULE
	$(Q)mkdir -p $(@D) $(DEPDIR) $(dir $(DEPFILE)) $(if $(filter 1,$(USE_CCACHE)),$(CCACHE_DIR),)
	$(Q)$(LOG_START)
	$(Q)$(LOCAL_CLEAN)
	$(Q)$(CCACHE_ENV) $(CXX_COMPILE) $(CXXFLAGS) $(DEPFLAGS) \
	      $(USUAL_INCLUDE_PATHS) $(INCLUDES_EXTRA) \
	      -c $< -o $(OBJTMP)/$(basename $(notdir $@)).o
	$(Q)$(CXX_LINK) $(LDFLAGS_E) \
	      $(OBJTMP)/$(basename $(notdir $@)).o \
	      $(LDLIBS_common) $(LDLIBS_EXTRA) -o $@
	$(Q)$(LOG_END)
endef

define LINK_RULE
	$(Q)$(CXX_LINK) $(LDFLAGS_E) $^ $(LDLIBS_common) $(LDLIBS_EXTRA) -o $@
endef

# -----------------------------------------------------------------------------
# 8) Static archives — fast & smart repacking
# -----------------------------------------------------------------------------
# IMPORTANT:
#  - We do NOT create empty .a files. If there are no objects, we do nothing.
#  - By default tests DO NOT touch archives; AUTO_PREP controls priming.
#  - lib-bundles repacks only if missing/empty OR any *.o is newer than the .a.

libcommon_a := $(OUTPUT_PATH)/libcommon.a
libcurl_a   := $(OUTPUT_PATH)/libcurlwrap.a
libssl_a    := $(OUTPUT_PATH)/libsslwrap.a
libtorch_a  := $(OUTPUT_PATH)/libtorchwrap.a

# Optional tracing of the shell body when SHOW_CMD=1
ifeq ($(SHOW_CMD_ON),)
  SH_TRACE :=
else
  SH_TRACE := set -x;
endif

# Smart repack helper: safe when dir missing / empty; prints clear errors on failure

define MAYBE_PACK
	$(Q)$(SH_TRACE) \
	out="$(strip $(1))"; dir="$(strip $(2))"; \
	if [ -d "$$dir" ]; then \
	  objs="$$(find "$$dir" -type f -name '*.o' -print 2>/dev/null)"; \
	  if [ -n "$$objs" ]; then \
	    need=0; \
	    if [ ! -s "$$out" ]; then need=1; \
	    else \
	      for f in $$objs; do \
	        if [ "$$f" -nt "$$out" ]; then need=1; break; fi; \
	      done; \
	    fi; \
	    if [ $$need -eq 1 ]; then \
	      mkdir -p "$$(dirname "$$out")" || { echo "lib-bundles: mkdir failed for $$out" >&2; exit 1; }; \
	      $(AR) rcs "$$out" $$objs       || { echo "lib-bundles: ar failed for $$out"    >&2; exit 1; }; \
	      printf "$(COLOR_DIM_YELLOW)[$(COLOR_GRAY)MODULE:$(COLOR_DIM_GREEN)OK$(COLOR_DIM_YELLOW)]$(COLOR_RESET)  $(COLOR_GREEN)%s$(COLOR_RESET)\n" "$$out"; \
	    fi; \
	  fi; \
	fi; :
endef

# and (optional but recommended) remove the cosmetic alignment spaces:
lib-bundles:
	$(call MAYBE_PACK,$(libcommon_a),$(OUTPUT_PATH)/common)
	$(call MAYBE_PACK,$(libcurl_a),$(OUTPUT_PATH)/libcurl)
	$(call MAYBE_PACK,$(libssl_a),$(OUTPUT_PATH)/openssl)
	$(call MAYBE_PACK,$(libtorch_a),$(OUTPUT_PATH)/libtorch)

# -----------------------------------------------------------------------------
# 9) Sugar Macros for Source Makefiles (producers)
# -----------------------------------------------------------------------------
define BUILD_OBJ
$$(OUTPUT_PATH)/$$(strip $(1))/$$(strip $(2)).o: $$(HERE_PATH)/$$(strip $(2)).cpp
	$$(CC_RULE)

.PHONY: $$(strip $(3))
$$(strip $(3)): $$(OUTPUT_PATH)/$$(strip $(1))/$$(strip $(2)).o
	$$(Q)printf "$(COLOR_DIM_YELLOW)[$(COLOR_GRAY)MODULE:$(COLOR_DIM_GREEN)OK$(COLOR_DIM_YELLOW)]$(COLOR_RESET)  $(COLOR_GREEN)%s/$(notdir $$@)$(COLOR_RESET)\n" "$(REL_MODULE)"
endef

define BUILD_OBJ_INC
$$(OUTPUT_PATH)/$$(strip $(1))/$$(strip $(2)).o: INCLUDES_EXTRA := $$(strip $(4))
$$(eval $$(call BUILD_OBJ,$$(strip $(1)),$$(strip $(2)),$$(strip $(3))))
endef

# -----------------------------------------------------------------------------
# 10) Test Helpers (one-file tests + dispatcher)
# -----------------------------------------------------------------------------
TEST_DEFAULT_LDLIBS ?= $(libcommon_a)

# ---- Fast test toggle ----
# Default: assume impl + archives are already built (no prework).
# Use AUTO_PREP=1 to auto-prime a clean tree once (smart + cheap).
AUTO_PREP ?= 0

ifeq ($(AUTO_PREP),1)
  ORDER_PREP := autoprep lib-bundles
else
  ORDER_PREP :=
endif

# Light auto-prime:
#  - If any archive is missing or empty, build impl/all, then pack as needed.
.PHONY: autoprep
autoprep:
	$(Q)set -e; need=0; \
	for a in $(libcommon_a) $(libtorch_a) $(libcurl_a) $(libssl_a); do \
	  if [ ! -s $$a ]; then need=1; break; fi; \
	done; \
	if [ $$need -eq 1 ]; then \
	  echo "$(COLOR_GRAY)[TEST] priming modules (archives missing/empty)$(COLOR_RESET)"; \
	  $(MAKE) -C $(IMPL_PATH) all; \
	  $(MAKE) lib-bundles; \
	fi

# ------------- TEST_ONEFILE -------------
define TEST_ONEFILE
$(1)_DEPS := $(filter %.a,$(TEST_DEFAULT_LDLIBS) $(3))

# Source MUST be first prerequisite so the compile line is unambiguous.
$$(TEST_OUT)/$$(strip $(1)): $$(HERE_PATH)/$$(strip $(2)) $$($(1)_DEPS) | $$(ORDER_PREP)
	$(Q)mkdir -p $$(@D) $$(DEPDIR) $$(OBJTMP) $$(if $$(filter 1,$$(USE_CCACHE)),$$(CCACHE_DIR),)
	$(Q)$$(LOG_START)
	$(Q)$$(LOCAL_CLEAN)
	# Compile the real source (explicit path avoids $< pitfalls)
	$(Q)$$(CCACHE_ENV) $$(CXX_COMPILE) $$(CXXFLAGS) \
	      -MMD -MP -MF $$(DEPDIR)/$$(basename $$(notdir $$@)).d -MT $$@ \
	      $$(USUAL_INCLUDE_PATHS) $$(INCLUDES_EXTRA) \
	      -c $$(HERE_PATH)/$$(strip $(2)) -o $$(OBJTMP)/$$(basename $$(notdir $$@)).o
	# Link
	$(Q)$$(CXX_LINK) $$(LDFLAGS_E) \
	      $$(OBJTMP)/$$(basename $$(notdir $$@)).o \
	      $$(LDLIBS_common) $$(TEST_DEFAULT_LDLIBS) $(3) $$(LDLIBS_EXTRA) \
	      -o $$@
	$(Q)$$(LOG_END)

.PHONY: run-$$(strip $(1))
run-$$(strip $(1)): $$(TEST_OUT)/$$(strip $(1))
	$(Q)$$(RUN_MODE) $$(TEST_OUT)/$$(strip $(1))
endef

# -----------------------------------------------------------------------------
# 11) Dispatcher (build-first, then run)
#   Running `make -C tests test_<name> SHOW_CMD=1` shows g++ commands
#   whenever the test needs to be rebuilt.
#   If build fails (likely missing archives), we print a hint for AUTO_PREP=1.
# -----------------------------------------------------------------------------
# Set FORCE_TEST_REBUILD=1 to always rebuild test binaries before execution.
FORCE_TEST_REBUILD ?= 0
FORCE_TEST_REBUILD_ON := $(filter 1 yes true on,$(strip $(FORCE_TEST_REBUILD)))

define FORWARD_ONE
.PHONY: test_$(1)
test_$(1):
	$(Q)echo "$(COLOR_GRAY)[DISPATCH_TEST]$(COLOR_RESET) $(2)/test_$(1)"
	# Optional force rebuild for debugging; default keeps existing binary.
	$(if $(FORCE_TEST_REBUILD_ON),$(Q)rm -f '$(TEST_OUT)/test_$(1)' || true)
	# Build first (shows compile/link if anything is stale)
	$(Q)+{ \
	  $(MAKE) -C $(2) $(TEST_OUT)/test_$(1) || { \
	    echo "$(COLOR_GRAY)[HINT]$(COLOR_RESET) If this failed due to missing archives, try: AUTO_PREP=1 make -C tests $@"; \
	    exit 1; \
	  }; \
	}
	# Then run (kept separate to avoid hiding build commands)
	$(Q)+$(MAKE) -C $(2) run-test_$(1)
endef
