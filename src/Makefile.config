# =============================================================================
# Makefile.config  —  project‑wide build configuration & reusable rules
#
# Goals:
#   - One place for toolchain flags, include paths, and linker libs
#   - Reliable header dependency tracking (automatic .d files)
#   - Small, declarative Makefiles in subdirs (use macros; don’t copy/paste)
#   - Module isolation: only pull heavy deps (Torch/CUDA/SSL/CURL) where needed
#   - Fast links: build per‑module static archives once, reuse across tests
# =============================================================================


# -----------------------------------------------------------------------------
# 0) Toolchain & Core Flags
# -----------------------------------------------------------------------------
CXX            := g++
CXX_STANDARD   := c++20

COMMON_WARN    := -Wall -Wno-unused-function
DEBUG_FLAGS    := -g -Og -fno-omit-frame-pointer -rdynamic

# Compile-time hardening (applies to all .o builds)
SEC_CFLAGS     := -fstack-protector-strong -D_FORTIFY_SOURCE=2 -fPIC
# Link-time hardening (applies to final executables)
SEC_LDFLAGS    := -pie -fPIE

CXXFLAGS      += -std=$(CXX_STANDARD) $(COMMON_WARN) $(DEBUG_FLAGS) $(SEC_CFLAGS)
LDFLAGS       += $(SEC_LDFLAGS)


# ---- Verbose toggle ----------------------------------------------------------
# Set SHOW_CMD=1 (or yes/true/on) to print full build commands.
SHOW_CMD ?= 0
SHOW_CMD_ON := $(filter 1 yes true on,$(SHOW_CMD))
Q := $(if $(SHOW_CMD_ON),,@)   # use $(Q) instead of leading '@' in recipes

# Keep make quiet by default, but drop -s when SHOW_CMD is on
ifeq ($(SHOW_CMD_ON),)
MAKEFLAGS     += --no-builtin-rules --no-print-directory -s
else
MAKEFLAGS     += --no-builtin-rules --no-print-directory
endif


# -----------------------------------------------------------------------------
# 1) Project Layout
# -----------------------------------------------------------------------------
OUTPUT_PATH := $(ROOT_PATH)/build
IMPL_PATH   := $(ROOT_PATH)/impl
CONFIG_PATH := $(ROOT_PATH)/config
TESTS_PATH  := $(ROOT_PATH)/tests
TEST_OUT	  := $(TESTS_PATH)/build/

# -----------------------------------------------------------------------------
# 2) External SDK Locations
# -----------------------------------------------------------------------------
EXTERNAL_LIBS_PATH := /cuwacunu/external
LIBTORCH_PATH      := $(EXTERNAL_LIBS_PATH)/libtorch
LIBCUDA_PATH       := /usr/local/cuda-12.1
SSL_PATH           := /usr
LIBCURL_PATH       := /usr

# -----------------------------------------------------------------------------
# 3) Include Paths
# -----------------------------------------------------------------------------
USUAL_INCLUDE_PATHS    := -I$(ROOT_PATH)/ -I$(ROOT_PATH)/include -I$(ROOT_PATH)/include/torch_compat
TORCH_INCLUDE_PATHS    := -I$(LIBTORCH_PATH)/include -I$(LIBTORCH_PATH)/include/torch/csrc/api/include -I$(LIBCUDA_PATH)/include
SSL_INCLUDE_PATHS      := -I$(SSL_PATH)/include
LIBCURL_INCLUDE_PATHS  := -I$(LIBCURL_PATH)/include
NCURSES_INCLUDE_PATHS  := -I/usr/include/ncursesw


# -----------------------------------------------------------------------------
# 4) Link Libraries (system libs)
# -----------------------------------------------------------------------------
LDLIBS_common := -lstdc++ -lpthread -lm

LDLIBS_torch  := -L$(LIBTORCH_PATH)/lib -L$(LIBCUDA_PATH)/lib64 \
                  -Wl,-rpath,$(LIBTORCH_PATH)/lib \
                  -ltorch_cuda -lc10_cuda -ltorch_cpu -ltorch -lcudnn -lc10 \
                  -lcuda -lcudart -lnvToolsExt

LDLIBS_ssl    := -L$(SSL_PATH)/lib/x86_64-linux-gnu/ -lcrypto -lssl
LDLIBS_curl   := -lcurl

LDLIBS_ncurses := -lncursesw
NCURSES_LD_LAGS := $(LDLIBS_ncurses)

# -----------------------------------------------------------------------------
# 5) Dependency (.d) Files
#    - Write all depfiles under build/.deps mirroring object subdirs
#    - -MT $@ guarantees the first target in the .d matches the object path
#    - Globally include all depfiles so header edits trigger rebuilds anywhere
# -----------------------------------------------------------------------------
DEPDIR   := $(OUTPUT_PATH)/.deps
OBJTMP   := $(OUTPUT_PATH)/.objs

DEPFLAGS = -MMD -MP -MF $(DEPDIR)/$(basename $(notdir $@)).d -MT $@

# Include all known depfiles (safe if none exist yet)
-include $(shell test -d $(DEPDIR) && find $(DEPDIR) -name '*.d' -print)

# -----------------------------------------------------------------------------
# 6) Logging & Quality-of-life Macros (with runtime SHA-256)
# -----------------------------------------------------------------------------
COLOR_GREEN  := \033[32m
COLOR_DIM_GREEN := \033[2;32m
COLOR_YELLOW := \033[33m
COLOR_DIM_YELLOW := \033[2;33m
COLOR_RED    := \033[31m
COLOR_GRAY   := \033[90m
COLOR_RESET  := \033[0m

# Start: show previous hash of the .o (if any)
LOG_START = { \
  printf "$(COLOR_DIM_YELLOW)[$(COLOR_GRAY)OBJ:$(COLOR_DIM_YELLOW)BUILD]$(COLOR_RESET)  \
$(COLOR_GRAY)%-70s request to build.$(COLOR_RESET)\n" "$(notdir $@)"; \
}

# End: show new hash of the .o (now built)
LOG_END = { \
  sha="$$(sha256sum '$@' 2>/dev/null | awk '{print $$1}')"; \
  md5="$$(md5sum    '$@' 2>/dev/null | awk '{print $$1}')"; \
  printf "$(COLOR_DIM_YELLOW)[$(COLOR_GRAY)OBJ:$(COLOR_DIM_GREEN)   OK$(COLOR_DIM_YELLOW)]$(COLOR_RESET)  \
$(COLOR_GRAY)%-70s $(COLOR_GRAY)[$(COLOR_DIM_YELLOW)sha256:$(COLOR_GRAY)%s][$(COLOR_DIM_YELLOW)md5:$(COLOR_GRAY)%s]$(COLOR_RESET)\n" "$(notdir $@)" "$$sha" "$$md5"; \
} || printf "$(COLOR_DIM_YELLOW)    [OBJ:$(COLOR_RED)FAIL$(COLOR_DIM_YELLOW) ]$(COLOR_RESET)  %-20s (exit %s)\n" \
       "$(notdir $@)" "$$?"

# Success line: no hashing (we’re only reporting .o hashes)
LOG_SUCCESS = if [ "$@" = "all" ]; then \
    printf "$(COLOR_DIM_YELLOW)[$(COLOR_GRAY)MODULE:$(COLOR_DIM_GREEN)OK$(COLOR_DIM_YELLOW)]$(COLOR_RESET)  \
	$(COLOR_GREEN)%-70s $(COLOR_RESET)\n" "$(REL_MODULE)"; \
  else \
    printf "$(COLOR_DIM_YELLOW)[$(COLOR_GRAY)MODULE:$(COLOR_DIM_GREEN)OK$(COLOR_DIM_YELLOW)]$(COLOR_RESET)  \
	$(COLOR_GREEN)%-70s $(COLOR_RESET)\n" "$(REL_MODULE)/$(notdir $@)"; \
  fi


# Remove stale output before re‑creating (defends against debugging leftovers)
LOCAL_CLEAN = { [ -f $@ ] && shred -u $@ || true; }

# Optional run modes used by tests/binaries (set RUN_MODE in leaf Makefiles)
PLAIN       :=
GDB         := gdb -ex "set print thread-events off" -ex run
GDB_TORCH   := CUDA_LAUNCH_BLOCKING=1 TORCH_SHOW_CPP_STACKTRACES=1 $(GDB)
VALGRIND    := valgrind --leak-check=full -s --show-leak-kinds=all \
                 --suppressions=$(CONFIG_PATH)/valgrind.supp \
                 --gen-suppressions=all \
                 --log-file=$(ROOT_PATH)/src/valgrind.log
RUN_MODE = $(PLAIN)

# -----------------------------------------------------------------------------
# 7) Central Build Rules
#    - CC_RULE: compile .cpp → .o with depfile generation
#    - ONEFILE_EXE_RULE: compile one .cpp to a temp .o, then link an exe
#    - LINK_RULE: link an exe from a list of prebuilt objects/libs
#
#    Target-specific vars recognized:
#      - INCLUDES_EXTRA : extra -I paths for that target
#      - LDLIBS_EXTRA   : extra libs and/or static archives for linker
# -----------------------------------------------------------------------------
define CC_RULE
	$(Q)mkdir -p $(@D) $(DEPDIR)
	$(Q)$(LOG_START) && $(LOCAL_CLEAN) && \
	$(CXX) $(CXXFLAGS) $(DEPFLAGS) \
	      $(USUAL_INCLUDE_PATHS) $(INCLUDES_EXTRA) \
	      -c $< -o $@ && $(LOG_END)
endef

define ONEFILE_EXE_RULE
	$(Q)mkdir -p $(@D) $(DEPDIR) $(OBJTMP)
	$(Q)$(LOG_START) && $(LOCAL_CLEAN) && \
	$(CXX) $(CXXFLAGS) $(DEPFLAGS) \
	      $(USUAL_INCLUDE_PATHS) $(INCLUDES_EXTRA) \
	      -c $< -o $(OBJTMP)/$(basename $(notdir $@)).o && \
	$(CXX) $(LDFLAGS) \
	      $(OBJTMP)/$(basename $(notdir $@)).o \
	      $(LDLIBS_common) $(LDLIBS_EXTRA) -o $@ && $(LOG_END)
endef

define LINK_RULE
	$(CXX) $(LDFLAGS) $^ $(LDLIBS_common) $(LDLIBS_EXTRA) -o $@
endef


# -----------------------------------------------------------------------------
# 8) Per‑Module Static Archives (built once, reused everywhere)
#    - Each wraps all .o built under its module dir
#    - Consumers (tests/binaries) link these archives + system libs
# -----------------------------------------------------------------------------
libcommon_a   := $(OUTPUT_PATH)/libcommon.a
libcurl_a     := $(OUTPUT_PATH)/libcurlwrap.a
libssl_a      := $(OUTPUT_PATH)/libsslwrap.a
libtorch_a    := $(OUTPUT_PATH)/libtorchwrap.a

COMMON_OBJS   := $(wildcard $(OUTPUT_PATH)/common/*.o)
LIBCURL_OBJS  := $(wildcard $(OUTPUT_PATH)/libcurl/*.o)
OPENSSL_OBJS  := $(wildcard $(OUTPUT_PATH)/openssl/*.o)
LIBTORCH_OBJS := $(wildcard $(OUTPUT_PATH)/libtorch/*.o)

$(libcommon_a):  $(COMMON_OBJS)   ; @mkdir -p $(@D); ar rcs $@ $^
$(libcurl_a):    $(LIBCURL_OBJS)  ; @mkdir -p $(@D); ar rcs $@ $^
$(libssl_a):     $(OPENSSL_OBJS)  ; @mkdir -p $(@D); ar rcs $@ $^
$(libtorch_a):   $(LIBTORCH_OBJS) ; @mkdir -p $(@D); ar rcs $@ $^

# Convenience umbrella (ensures all archives up‑to‑date before linking)
.PHONY: lib-bundles
lib-bundles: $(libcommon_a) $(libcurl_a) $(libssl_a) $(libtorch_a)
	@$(LOG_SUCCESS)


# -----------------------------------------------------------------------------
# 9) Sugar Macros for Source Makefiles (producers)
#    Build exactly one .cpp (from HERE_PATH) into build/<MODULE>/<NAME>.o
#    and expose a friendly phony goal (ALIAS) to trigger it.
#
#    Parameters:
#      (1) MODULE  – bucket under $(OUTPUT_PATH) where the .o will live
#                    (e.g., common, libtorch, openssl, libcurl). This also
#                    determines which per-module static archive (§8) may
#                    later collect the object.
#      (2) NAME    – basename of the .cpp inside $(HERE_PATH) (omit “.cpp”).
#      (3) ALIAS   – phony goal you can depend on from “all”. Choose any
#                    label; it does not need to match MODULE or NAME.
#      (4) EXTRA   – (BUILD_OBJ_INC only) extra include paths, space-separated.
#
#    Typical leaf Makefile (under $(IMPL_PATH)):
#
#      ROOT_PATH := ../../..
#      include $(ROOT_PATH)/Makefile.config
#
#      # Where the sources live (e.g., mdn_head.cpp, mdn_loss.cpp, …)
#      HERE_PATH   := $(IMPL_PATH)/wikimyei/mdn
#      # Optional: nicer log prefix
#      REL_MODULE  := $(patsubst $(IMPL_PATH)/%,%,$(HERE_PATH))
#
#      # Example 1 (no extra -I):
#      #   mdn_head.cpp → build/common/mdn_head.o, exposed via “build_mdn_head”
#      $(eval $(call BUILD_OBJ,common,mdn_head,build_mdn_head))
#
#      # Example 2 (with extra -I):
#      #   mdn_loss.cpp → build/libtorch/mdn_loss.o, exposed via “compile_mdn_loss”
#      $(eval $(call BUILD_OBJ_INC,libtorch,mdn_loss,compile_mdn_loss,$(TORCH_INCLUDE_PATHS) $(SSL_INCLUDE_PATHS)))
#
#      # Drive both builds:
#      all: build_mdn_head compile_mdn_loss
#
#    Notes:
#      - One macro invocation per .cpp you want built.
#      - Do NOT list .o prerequisites — header deps are tracked via depfiles.
#      - Do NOT depend on lib*.a here — archives are produced separately (§8).
# -----------------------------------------------------------------------------
define BUILD_OBJ
$$(OUTPUT_PATH)/$$(strip $(1))/$$(strip $(2)).o: $$(HERE_PATH)/$$(strip $(2)).cpp
	$$(CC_RULE)

.PHONY: $$(strip $(3))
$$(strip $(3)): $$(OUTPUT_PATH)/$$(strip $(1))/$$(strip $(2)).o
	@$$(LOG_SUCCESS)
endef

# Variant that accepts extra include paths as param 4
# Example:
#   $(eval $(call BUILD_OBJ_INC,libtorch,mdn_loss,compile_mdn_loss,$(TORCH_INCLUDE_PATHS) $(SSL_INCLUDE_PATHS)))
define BUILD_OBJ_INC
$$(OUTPUT_PATH)/$$(strip $(1))/$$(strip $(2)).o: INCLUDES_EXTRA := $$(strip $(4))
$$(eval $$(call BUILD_OBJ,$$(strip $(1)),$$(strip $(2)),$$(strip $(3))))
endef

# -----------------------------------------------------------------------------
# 10) Test Helpers (one-file tests)
#    Usage in a leaf tests Makefile:
#
#      ROOT_PATH := ../../../..
#      include $(ROOT_PATH)/Makefile.config
#      HERE_PATH   := $(TESTS_PATH)/bench/camahjucunu/bnf
#      REL_MODULE  := $(patsubst $(TESTS_PATH)/%,%,$(HERE_PATH))
#
#      # Optional overrides:
#      # TEST_OUT            ?= $(OUTPUT_PATH)
#      # TEST_DEFAULT_LDLIBS ?= $(libcommon_a)
#
#      $(eval $(call TEST_ONEFILE, test_bnf_grammar_lexer, test_bnf_grammar_lexer.cpp))
#      $(eval $(call TEST_ONEFILE, test_ssl_thing,        test_ssl_thing.cpp, $(libssl_a) $(LDLIBS_ssl)))
#
#      # Or build-only:
#      # $(eval $(call TEST_ONEFILE_NORUN, test_only_build, test_only_build.cpp))
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# 10) Test Helpers (one-file tests + dispatcher)
# -----------------------------------------------------------------------------
TEST_DEFAULT_LDLIBS ?= $(libcommon_a)

# Build-only (no run alias)
# $(1)=binary name (e.g. test_bnf_grammar_lexer)
# $(2)=source cpp (relative to HERE_PATH)
# $(3)=extra LDLIBS (optional; may include .a archives and -l flags)
define TEST_ONEFILE_NORUN
# Per-test: extract the .a archives from default + extra LDLIBS as hard deps
$(1)_DEPS := $(filter %.a,$(TEST_DEFAULT_LDLIBS) $(strip $(3)))

$$(TEST_OUT)/$$(strip $(1)): LDLIBS_EXTRA += $$(TEST_DEFAULT_LDLIBS) $$(strip $(3))
$$(TEST_OUT)/$$(strip $(1)): $$(HERE_PATH)/$$(strip $(2)) $$($(1)_DEPS)
	$(Q)mkdir -p $$(@D) $$(DEPDIR) $$(OBJTMP)
	$(Q)$$(LOG_START) && $$(LOCAL_CLEAN) && \
	$$(CXX) $$(CXXFLAGS) $$(DEPFLAGS) \
	      $$(USUAL_INCLUDE_PATHS) $$(INCLUDES_EXTRA) \
	      -c $$< -o $$(OBJTMP)/$$(basename $$(notdir $$@)).o && \
	$$(CXX) $$(LDFLAGS) \
	      $$(OBJTMP)/$$(basename $$(notdir $$@)).o \
	      $$(LDLIBS_common) $$(LDLIBS_EXTRA) -o $$@ && $$(LOG_END)
endef

# Build + namespaced run alias (prevents collisions)
define TEST_ONEFILE
$$(eval $$(call TEST_ONEFILE_NORUN,$(1),$(2),$(3)))
.PHONY: run-$$(strip $(1))
run-$$(strip $(1)): $$(TEST_OUT)/$$(strip $(1))
	@$$(RUN_MODE) $$(TEST_OUT)/$$(strip $(1))
endef

# Dispatcher helper for tests/Makefile (prefix-safe)
# $(1) = bare name (without 'test_'), $(2) = subdir path
define FORWARD_ONE
.PHONY: test_$(1)
test_$(1):
	@echo "$(COLOR_GRAY)[DISPATCH_TEST]$(COLOR_RESET) $(2)/$(1)"
	@$(MAKE) -C $(2) run-test_$(1) \
	 || $(MAKE) -C $(2) $(OUTPUT_PATH)/test_$(1) \
	 || $(MAKE) -C $(2) test_$(1)
endef
