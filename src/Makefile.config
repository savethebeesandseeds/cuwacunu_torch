# =============================================================================
# Makefile.config  —  project-wide build configuration & reusable rules (TESTS)
#
# Goals:
#   - One place for toolchain flags, include paths, and linker libs
#   - Reliable header dependency tracking (automatic .d files)
#   - Small, declarative Makefiles in subdirs (use macros; don’t copy/paste)
#   - Module isolation: only pull heavy deps (Torch/CUDA/SSL/CURL) where needed
#   - Fast links: build per-module static archives once, reuse across tests
#
# Notes for the tests tree:
#   • This file is included by test Makefiles under /tests/bench/… only.
#   • When tests recursively build code under /impl/…, those sub-makes include
#     their own Makefile.config (the “root” one), not this file.
#   • Section numbers/comments mirror the root config for familiarity.
# =============================================================================


# -----------------------------------------------------------------------------
# 0) Toolchain & Core Flags
# -----------------------------------------------------------------------------
CXX            := g++
CXX_STANDARD   := c++20

COMMON_WARN    := -Wall -Wno-unused-function
DEBUG_FLAGS    := -g -Og -fno-omit-frame-pointer -rdynamic

# Compile-time hardening (applies to all .o builds)
SEC_CFLAGS     := -fstack-protector-strong -D_FORTIFY_SOURCE=2 -fPIC
# Link-time hardening (applies to final executables)
SEC_LDFLAGS    := -pie -fPIE

CXXFLAGS      += -std=$(CXX_STANDARD) $(COMMON_WARN) $(DEBUG_FLAGS) $(SEC_CFLAGS)
LDFLAGS       += $(SEC_LDFLAGS)


# ---- Verbose toggle ----------------------------------------------------------
# Set SHOW_CMD=1 (or yes/true/on) to print full build commands.
SHOW_CMD ?= 0
SHOW_CMD_ON := $(filter 1 yes true on,$(SHOW_CMD))
Q := $(if $(SHOW_CMD_ON),,@)   # use $(Q) instead of leading '@' in recipes

# Keep make quiet by default, but drop -s when SHOW_CMD is on
ifeq ($(SHOW_CMD_ON),)
MAKEFLAGS     += --no-builtin-rules --no-print-directory -s
else
MAKEFLAGS     += --no-builtin-rules --no-print-directory
endif


# -----------------------------------------------------------------------------
# 1) Project Layout
# -----------------------------------------------------------------------------
OUTPUT_PATH := $(ROOT_PATH)/build
IMPL_PATH   := $(ROOT_PATH)/impl
CONFIG_PATH := $(ROOT_PATH)/config
TESTS_PATH  := $(ROOT_PATH)/tests

# Normalize TEST_OUT (no trailing slash) to avoid “//” in paths/targets
TEST_OUT    := $(patsubst %/,%,$(TESTS_PATH)/build)


# -----------------------------------------------------------------------------
# 2) External SDK Locations
# -----------------------------------------------------------------------------
EXTERNAL_LIBS_PATH := /cuwacunu/external
LIBTORCH_PATH      := $(EXTERNAL_LIBS_PATH)/libtorch
LIBCUDA_PATH       := /usr/local/cuda-12.1
SSL_PATH           := /usr
LIBCURL_PATH       := /usr


# -----------------------------------------------------------------------------
# 3) Include Paths
# -----------------------------------------------------------------------------
USUAL_INCLUDE_PATHS    := -I$(ROOT_PATH)/ -I$(ROOT_PATH)/include -I$(ROOT_PATH)/include/torch_compat
TORCH_INCLUDE_PATHS    := -I$(LIBTORCH_PATH)/include -I$(LIBTORCH_PATH)/include/torch/csrc/api/include -I$(LIBCUDA_PATH)/include
SSL_INCLUDE_PATHS      := -I$(SSL_PATH)/include
LIBCURL_INCLUDE_PATHS  := -I$(LIBCURL_PATH)/include
NCURSES_INCLUDE_PATHS  := -I/usr/include/ncursesw


# -----------------------------------------------------------------------------
# 4) Link Libraries (system libs)
# -----------------------------------------------------------------------------
LDLIBS_common := -lstdc++ -lpthread -lm

LDLIBS_torch  := -L$(LIBTORCH_PATH)/lib -L$(LIBCUDA_PATH)/lib64 \
                  -Wl,-rpath,$(LIBTORCH_PATH)/lib \
                  -ltorch_cuda -lc10_cuda -ltorch_cpu -ltorch -lcudnn -lc10 \
                  -lcuda -lcudart -lnvToolsExt

LDLIBS_ssl    := -L$(SSL_PATH)/lib/x86_64-linux-gnu/ -lcrypto -lssl
LDLIBS_curl   := -lcurl

# Keep original naming for ncurses compatibility across the tests tree
LDLIBS_ncurses  := -lncursesw
NCURSES_LD_LAGS := $(LDLIBS_ncurses)


# -----------------------------------------------------------------------------
# 5) Dependency (.d) Files
#    - Write depfiles under build/.deps mirroring object subpaths
#    - -MT $@ guarantees the first target in the .d matches the path we rebuild
#    - For one-file test builds (TEST_ONEFILE), we override depflags to track
#      the executable (since the compile step uses a temporary object path).
# -----------------------------------------------------------------------------
DEPDIR   := $(OUTPUT_PATH)/.deps
OBJTMP   := $(OUTPUT_PATH)/.objs

# Object rules (CC_RULE) write depfiles alongside $(OUTPUT_PATH) tree
DEPFILE  = $(DEPDIR)/$(@:$(OUTPUT_PATH)/%=%:.o=.d)
DEPFLAGS = -MMD -MP -MF $(DEPFILE) -MT $@

# Include all known depfiles (safe if none exist yet)
-include $(shell test -d $(DEPDIR) && find $(DEPDIR) -name '*.d' -print)


# -----------------------------------------------------------------------------
# 6) Logging & Quality-of-life Macros (with runtime SHA-256)
# -----------------------------------------------------------------------------
COLOR_GREEN      := \033[32m
COLOR_DIM_GREEN  := \033[2;32m
COLOR_YELLOW     := \033[33m
COLOR_DIM_YELLOW := \033[2;33m
COLOR_RED        := \033[31m
COLOR_GRAY       := \033[90m
COLOR_RESET      := \033[0m

# Start: show previous hash of the .o (if any)
LOG_START = { \
  printf "$(COLOR_DIM_YELLOW)[$(COLOR_GRAY)OBJ:$(COLOR_DIM_YELLOW)BUILD]$(COLOR_RESET)  \
$(COLOR_GRAY)%-70s request to build.$(COLOR_RESET)\n" "$(notdir $@)"; \
}

# End: show new hash of the target (object or exe)
LOG_END = { \
  sha="$$(sha256sum '$@' 2>/dev/null | awk '{print $$1}')"; \
  md5="$$(md5sum    '$@' 2>/dev/null | awk '{print $$1}')"; \
  printf "$(COLOR_DIM_YELLOW)[$(COLOR_GRAY)OBJ:$(COLOR_DIM_GREEN)   OK$(COLOR_DIM_YELLOW)]$(COLOR_RESET)  \
$(COLOR_GRAY)%-70s $(COLOR_GRAY)[$(COLOR_DIM_YELLOW)sha256:$(COLOR_GRAY)%s][$(COLOR_DIM_YELLOW)md5:$(COLOR_GRAY)%s]$(COLOR_RESET)\n" "$(notdir $@)" "$$sha" "$$md5"; \
} || printf "$(COLOR_DIM_YELLOW)    [OBJ:$(COLOR_RED)FAIL$(COLOR_DIM_YELLOW) ]$(COLOR_RESET)  %-20s (exit %s)\n" \
       "$(notdir $@)" "$$?"

# Success line: no hashing (module-level notices)
LOG_SUCCESS = if [ "$@" = "all" ]; then \
    printf "$(COLOR_DIM_YELLOW)[$(COLOR_GRAY)MODULE:$(COLOR_DIM_GREEN)OK$(COLOR_DIM_YELLOW)]$(COLOR_RESET)  \
	$(COLOR_GREEN)%-70s $(COLOR_RESET)\n" "$(REL_MODULE)"; \
  else \
    printf "$(COLOR_DIM_YELLOW)[$(COLOR_GRAY)MODULE:$(COLOR_DIM_GREEN)OK$(COLOR_DIM_YELLOW)]$(COLOR_RESET)  \
	$(COLOR_GREEN)%-70s $(COLOR_RESET)\n" "$(REL_MODULE)/$(notdir $@)"; \
  fi

# Remove stale output before re-creating (defends against debugging leftovers)
LOCAL_CLEAN = { [ -f $@ ] && shred -u $@ || true; }

# Optional run modes used by tests/binaries (set RUN_MODE in leaf Makefiles)
PLAIN       :=
GDB         := gdb -ex "set print thread-events off" -ex run
GDB_TORCH   := CUDA_LAUNCH_BLOCKING=1 TORCH_SHOW_CPP_STACKTRACES=1 $(GDB)
VALGRIND    := valgrind --leak-check=full -s --show-leak-kinds=all \
                 --suppressions=$(CONFIG_PATH)/valgrind.supp \
                 --gen-suppressions=all \
                 --log-file=$(ROOT_PATH)/src/valgrind.log
RUN_MODE = $(PLAIN)


# -----------------------------------------------------------------------------
# 7) Central Build Rules
#    - CC_RULE: compile .cpp → .o with depfile generation
#    - ONEFILE_EXE_RULE: compile one .cpp to a temp .o, then link an exe
#    - LINK_RULE: link an exe from a list of prebuilt objects/libs
#
#    Target-specific vars recognized:
#      - INCLUDES_EXTRA : extra -I paths for that target
#      - LDLIBS_EXTRA   : extra libs and/or static archives for linker
#
#    NOTE: TEST_ONEFILE uses its own depflags (below) to track the exe.
# -----------------------------------------------------------------------------
define CC_RULE
	$(Q)mkdir -p $(@D) $(DEPDIR) $(dir $(DEPFILE))
	$(Q)$(LOG_START) && $(LOCAL_CLEAN) && \
	$(CXX) $(CXXFLAGS) $(DEPFLAGS) \
	      $(USUAL_INCLUDE_PATHS) $(INCLUDES_EXTRA) \
	      -c $< -o $@ && $(LOG_END)
endef

define ONEFILE_EXE_RULE
	$(Q)mkdir -p $(@D) $(DEPDIR) $(dir $(DEPFILE))
	$(Q)$(LOG_START) && $(LOCAL_CLEAN) && \
	$(CXX) $(CXXFLAGS) $(DEPFLAGS) \
	      $(USUAL_INCLUDE_PATHS) $(INCLUDES_EXTRA) \
	      -c $< -o $(OBJTMP)/$(basename $(notdir $@)).o && \
	$(CXX) $(LDFLAGS) \
	      $(OBJTMP)/$(basename $(notdir $@)).o \
	      $(LDLIBS_common) $(LDLIBS_EXTRA) -o $@ && $(LOG_END)
endef

define LINK_RULE
	$(CXX) $(LDFLAGS) $^ $(LDLIBS_common) $(LDLIBS_EXTRA) -o $@
endef


# -----------------------------------------------------------------------------
# 8) Per-Module Static Archives (built once, reused everywhere)
#    - Each wraps all .o built under its module dir
#    - Consumers (tests/binaries) link these archives + system libs
#    - Safe on empty object sets (we create an empty archive file)
#
#    Implementation detail:
#      We use .SECONDEXPANSION and $(wildcard …) so that prereqs are re-evaluated
#      at *build time* (not parse time). This ensures we always pack current
#      objects, even in the same make run.
# -----------------------------------------------------------------------------
libcommon_a   := $(OUTPUT_PATH)/libcommon.a
libcurl_a     := $(OUTPUT_PATH)/libcurlwrap.a
libssl_a      := $(OUTPUT_PATH)/libsslwrap.a
libtorch_a    := $(OUTPUT_PATH)/libtorchwrap.a

.SECONDEXPANSION:

$(libcommon_a):  $$(wildcard $(OUTPUT_PATH)/common/*.o)
	@mkdir -p $(@D)
	@rm -f $@
	@objs="$^"; if [ -n "$$objs" ]; then ar rcs $@ $$objs; else : > $@; fi

$(libcurl_a):    $$(wildcard $(OUTPUT_PATH)/libcurl/*.o)
	@mkdir -p $(@D)
	@rm -f $@
	@objs="$^"; if [ -n "$$objs" ]; then ar rcs $@ $$objs; else : > $@; fi

$(libssl_a):     $$(wildcard $(OUTPUT_PATH)/openssl/*.o)
	@mkdir -p $(@D)
	@rm -f $@
	@objs="$^"; if [ -n "$$objs" ]; then ar rcs $@ $$objs; else : > $@; fi

$(libtorch_a):   $$(wildcard $(OUTPUT_PATH)/libtorch/*.o)
	@mkdir -p $(@D)
	@rm -f $@
	@objs="$^"; if [ -n "$$objs" ]; then ar rcs $@ $$objs; else : > $@; fi

# Convenience umbrella (ensures all archives up-to-date before linking)
.PHONY: lib-bundles
lib-bundles: $(libcommon_a) $(libcurl_a) $(libssl_a) $(libtorch_a)
	@$(LOG_SUCCESS)


# -----------------------------------------------------------------------------
# 9) Sugar Macros for Source Makefiles (producers)
#    Build exactly one .cpp (from HERE_PATH) into build/<MODULE>/<NAME>.o
#    and expose a friendly phony goal (ALIAS) to trigger it.
#
#    Parameters:
#      (1) MODULE  – bucket under $(OUTPUT_PATH) where the .o will live
#      (2) NAME    – basename of the .cpp inside $(HERE_PATH) (omit “.cpp”).
#      (3) ALIAS   – phony goal for a nicer target name.
#      (4) EXTRA   – (BUILD_OBJ_INC only) extra include paths, space-separated.
# -----------------------------------------------------------------------------
define BUILD_OBJ
$$(OUTPUT_PATH)/$$(strip $(1))/$$(strip $(2)).o: $$(HERE_PATH)/$$(strip $(2)).cpp
	$$(CC_RULE)

.PHONY: $$(strip $(3))
$$(strip $(3)): $$(OUTPUT_PATH)/$$(strip $(1))/$$(strip $(2)).o
	@$$(LOG_SUCCESS)
endef

# Variant that accepts extra include paths as param 4
define BUILD_OBJ_INC
$$(OUTPUT_PATH)/$$(strip $(1))/$$(strip $(2)).o: INCLUDES_EXTRA := $$(strip $(4))
$$(eval $$(call BUILD_OBJ,$$(strip $(1)),$$(strip $(2)),$$(strip $(3))))
endef


# -----------------------------------------------------------------------------
# 10) Test Helpers (one-file tests + dispatcher)
#
#     TEST_ONEFILE_NORUN compiles a single source into a temporary object and
#     links an executable under $(TEST_OUT)/…  To make header edits rebuild the
#     executable, we write a depfile *for the exe* (not for the temp object):
#
#       -MF $(DEPDIR)/<exe>.d  -MT <exe>
#
#     This avoids the “opening dependency file … tests/build/test_… : No such
#     file or directory” error and keeps incremental rebuilds correct.
# -----------------------------------------------------------------------------
TEST_DEFAULT_LDLIBS ?= $(libcommon_a)

# Build-only (no run alias)
#  $(1)=binary name (e.g. test_bnf_grammar_lexer)
#  $(2)=source cpp (relative to HERE_PATH)
#  $(3)=extra LDLIBS (optional; may include .a archives and -l flags)
define TEST_ONEFILE_NORUN
# Per-test: extract the .a archives from default + extra LDLIBS as hard deps
$(1)_DEPS := $(filter %.a,$(TEST_DEFAULT_LDLIBS) $(strip $(3)))

$$(TEST_OUT)/$$(strip $(1)): LDLIBS_EXTRA += $$(TEST_DEFAULT_LDLIBS) $$(strip $(3))
$$(TEST_OUT)/$$(strip $(1)): $$(HERE_PATH)/$$(strip $(2)) $$($(1)_DEPS)
	$(Q)mkdir -p $$(@D) $$(DEPDIR) $$(OBJTMP)
	$(Q)$$(LOG_START) && $$(LOCAL_CLEAN) && \
	$$(CXX) $$(CXXFLAGS) \
	      -MMD -MP -MF $$(DEPDIR)/$$(basename $$(notdir $$@)).d -MT $$@ \
	      $$(USUAL_INCLUDE_PATHS) $$(INCLUDES_EXTRA) \
	      -c $$< -o $$(OBJTMP)/$$(basename $$(notdir $$@)).o && \
	$$(CXX) $$(LDFLAGS) \
	      $$(OBJTMP)/$$(basename $$(notdir $$@)).o \
	      $$(LDLIBS_common) $$(LDLIBS_EXTRA) -o $$@ && $$(LOG_END)
endef

# Build + namespaced run alias (prevents collisions)
define TEST_ONEFILE
$$(eval $$(call TEST_ONEFILE_NORUN,$(1),$(2),$(3)))
.PHONY: run-$$(strip $(1))
run-$$(strip $(1)): $$(TEST_OUT)/$$(strip $(1))
	@$$(RUN_MODE) $$(TEST_OUT)/$$(strip $(1))
endef


# -----------------------------------------------------------------------------
# 11) Dispatcher helper for tests/Makefile (prefix-safe)
#     - We forward jobserver tokens with '+' ONLY where Make will see them
#       (start of the recipe line), fixing “jobserver unavailable” warnings.
#     - Fallback uses $(TEST_OUT)/test_<name> (correct test location).
# -----------------------------------------------------------------------------
define FORWARD_ONE
.PHONY: test_$(1)
test_$(1):
	@echo "$(COLOR_GRAY)[DISPATCH_TEST]$(COLOR_RESET) $(2)/$(1)"
	@+$(MAKE) -C $(2) run-test_$(1) \
	 || +$(MAKE) -C $(2) $(TEST_OUT)/test_$(1) \
	 || +$(MAKE) -C $(2) test_$(1)
endef
