# =============================================================================
# Makefile.config — project-wide build configuration & reusable rules (TESTS)
#
# This file is included by test Makefiles under /tests/bench/... only.
# It provides:
#   • toolchain flags, include paths, linker libs
#   • reliable .d dependency tracking
#   • tiny leaf Makefiles (use TEST_ONEFILE)
#   • per-module static archives (reused by tests)
#   • a dispatcher helper that builds first, then runs
# =============================================================================

# -----------------------------------------------------------------------------
# 0) Toolchain & Core Flags
# -----------------------------------------------------------------------------
CXX          := g++
CXX_STANDARD := c++20

COMMON_WARN  := -Wall -Wno-unused-function
DEBUG_FLAGS  := -g -Og -fno-omit-frame-pointer -rdynamic

# Compile-time hardening (objects)
SEC_CFLAGS   := -fstack-protector-strong -D_FORTIFY_SOURCE=2 -fPIC
# Link-time hardening (executables)
SEC_LDFLAGS  := -pie -fPIE

CXXFLAGS     += -std=$(CXX_STANDARD) $(COMMON_WARN) $(DEBUG_FLAGS) $(SEC_CFLAGS)
LDFLAGS      += $(SEC_LDFLAGS)

# -----------------------------------------------------------------------------
# 0.1) SHOW_CMD toggle
# -----------------------------------------------------------------------------
SHOW_CMD ?= 0
SHOW_CMD_ON := $(filter 1 yes true on,$(strip $(SHOW_CMD)))
Q := $(if $(SHOW_CMD_ON),,@)

ifeq ($(SHOW_CMD_ON),)
  MAKEFLAGS += --no-builtin-rules --no-print-directory -s
else
  MAKEFLAGS += --no-builtin-rules --no-print-directory
endif

# Propagate the toggle to any sub-makes (important for the dispatcher)
MAKEFLAGS += SHOW_CMD=$(SHOW_CMD)

# -----------------------------------------------------------------------------
# 1) Project Layout
# -----------------------------------------------------------------------------
OUTPUT_PATH := $(ROOT_PATH)/build
IMPL_PATH   := $(ROOT_PATH)/impl
CONFIG_PATH := $(ROOT_PATH)/config
TESTS_PATH  := $(ROOT_PATH)/tests

# Absolute path (avoids // and mismatched -C sub-makes)
TESTS_PATH_ABS := $(abspath $(TESTS_PATH))
TEST_OUT       := $(patsubst %/,%,$(TESTS_PATH_ABS)/build)

# Build the whole impl tree (used by AUTO_PREP)
.PHONY: modules
modules:
	$(Q)+$(MAKE) -C $(IMPL_PATH) all

# -----------------------------------------------------------------------------
# 2) External SDK Locations
# -----------------------------------------------------------------------------
EXTERNAL_LIBS_PATH := /cuwacunu/external
LIBTORCH_PATH      := $(EXTERNAL_LIBS_PATH)/libtorch
LIBCUDA_PATH       := /usr/local/cuda-12.1
SSL_PATH           := /usr
LIBCURL_PATH       := /usr

# -----------------------------------------------------------------------------
# 3) Include Paths
# -----------------------------------------------------------------------------
USUAL_INCLUDE_PATHS   := -I$(ROOT_PATH)/ -I$(ROOT_PATH)/include -I$(ROOT_PATH)/include/torch_compat
TORCH_INCLUDE_PATHS   := -I$(LIBTORCH_PATH)/include -I$(LIBTORCH_PATH)/include/torch/csrc/api/include -I$(LIBCUDA_PATH)/include
SSL_INCLUDE_PATHS     := -I$(SSL_PATH)/include
LIBCURL_INCLUDE_PATHS := -I$(LIBCURL_PATH)/include
NCURSES_INCLUDE_PATHS := -I/usr/include/ncursesw

# -----------------------------------------------------------------------------
# 4) Link Libraries (system libs)
# -----------------------------------------------------------------------------
# NOTE: g++ links libstdc++ automatically; we keep -lstdc++ for clarity.
LDLIBS_common := -lstdc++ -lpthread -lm

LDLIBS_torch := -L$(LIBTORCH_PATH)/lib -L$(LIBCUDA_PATH)/lib64
LDLIBS_torch += -Wl,-rpath,$(LIBTORCH_PATH)/lib
LDLIBS_torch += -Wl,-rpath,$(LIBCUDA_PATH)/lib64
LDLIBS_torch += -ltorch_cuda -lc10_cuda -ltorch_cpu -ltorch -lcudnn -lc10
LDLIBS_torch += -lcuda -lcudart -lnvToolsExt

LDLIBS_ssl  := -L$(SSL_PATH)/lib/x86_64-linux-gnu/ -lcrypto -lssl
LDLIBS_curl := -lcurl

# Keep original naming for ncurses compatibility across the tests tree
LDLIBS_ncurses := -lncursesw
# If your distro needs it, uncomment:
# LDLIBS_ncurses := -lncursesw -ltinfo

# -----------------------------------------------------------------------------
# 5) Dependency (.d) Files
# -----------------------------------------------------------------------------
DEPDIR := $(OUTPUT_PATH)/.deps
OBJTMP := $(OUTPUT_PATH)/.objs

# Object rules (CC_RULE) write depfiles alongside $(OUTPUT_PATH) tree
DEPFILE  = $(DEPDIR)/$(@:$(OUTPUT_PATH)/%=%:.o=.d)
DEPFLAGS = -MMD -MP -MF $(DEPFILE) -MT $@

# Include all known depfiles (safe if none exist yet)
-include $(shell test -d $(DEPDIR) && find $(DEPDIR) -name '*.d' -print)

# -----------------------------------------------------------------------------
# 6) Logging (with runtime SHA-256)
# -----------------------------------------------------------------------------
COLOR_GREEN      := \033[32m
COLOR_DIM_GREEN  := \033[2;32m
COLOR_YELLOW     := \033[33m
COLOR_DIM_YELLOW := \033[2;33m
COLOR_RED        := \033[31m
COLOR_GRAY       := \033[90m
COLOR_RESET      := \033[0m

LOG_START = { \
  printf "$(COLOR_DIM_YELLOW)[$(COLOR_GRAY)OBJ:$(COLOR_DIM_YELLOW)BUILD]$(COLOR_RESET)  \
$(COLOR_GRAY)%-70s request to build.$(COLOR_RESET)\n" "$(notdir $@)"; \
}

LOG_END = { \
  sha="$$(sha256sum '$@' 2>/dev/null | awk '{print $$1}')"; \
  md5="$$(md5sum    '$@' 2>/dev/null | awk '{print $$1}')"; \
  printf "$(COLOR_DIM_YELLOW)[$(COLOR_GRAY)OBJ:$(COLOR_DIM_GREEN)   OK$(COLOR_DIM_YELLOW)]$(COLOR_RESET)  \
$(COLOR_GRAY)%-70s $(COLOR_GRAY)[$(COLOR_DIM_YELLOW)sha256:$(COLOR_GRAY)%s][$(COLOR_DIM_YELLOW)md5:$(COLOR_GRAY)%s]$(COLOR_RESET)\n" "$(notdir $@)" "$$sha" "$$md5"; \
} || printf "$(COLOR_DIM_YELLOW)    [OBJ:$(COLOR_RED)FAIL$(COLOR_DIM_YELLOW) ]$(COLOR_RESET)  %-20s (exit %s)\n" \
       "$(notdir $@)" "$$?"

# Remove stale output before re-creating (defends against stray files)
LOCAL_CLEAN = { [ -f $@ ] && shred -u $@ || true; }

# Optional run modes (tests may override RUN_MODE)
PLAIN     :=
GDB       := gdb -ex "set print thread-events off" -ex run
GDB_TORCH := CUDA_LAUNCH_BLOCKING=1 TORCH_SHOW_CPP_STACKTRACES=1 $(GDB)
VALGRIND  := valgrind --leak-check=full -s --show-leak-kinds=all \
               --suppressions=$(CONFIG_PATH)/valgrind.supp \
               --gen-suppressions=all \
               --log-file=$(ROOT_PATH)/src/valgrind.log
RUN_MODE  = $(PLAIN)

# -----------------------------------------------------------------------------
# 7) Central Build Rules (split lines so g++ shows clearly)
# -----------------------------------------------------------------------------
define CC_RULE
	$(Q)mkdir -p $(@D) $(DEPDIR) $(dir $(DEPFILE))
	$(Q)$(LOG_START)
	$(Q)$(LOCAL_CLEAN)
	$(Q)$(CXX) $(CXXFLAGS) $(DEPFLAGS) \
	      $(USUAL_INCLUDE_PATHS) $(INCLUDES_EXTRA) \
	      -c $< -o $@
	$(Q)$(LOG_END)
endef

define ONEFILE_EXE_RULE
	$(Q)mkdir -p $(@D) $(DEPDIR) $(dir $(DEPFILE))
	$(Q)$(LOG_START)
	$(Q)$(LOCAL_CLEAN)
	$(Q)$(CXX) $(CXXFLAGS) $(DEPFLAGS) \
	      $(USUAL_INCLUDE_PATHS) $(INCLUDES_EXTRA) \
	      -c $< -o $(OBJTMP)/$(basename $(notdir $@)).o
	$(Q)$(CXX) $(LDFLAGS) \
	      $(OBJTMP)/$(basename $(notdir $@)).o \
	      $(LDLIBS_common) $(LDLIBS_EXTRA) -o $@
	$(Q)$(LOG_END)
endef

define LINK_RULE
	$(Q)$(CXX) $(LDFLAGS) $^ $(LDLIBS_common) $(LDLIBS_EXTRA) -o $@
endef

# -----------------------------------------------------------------------------
# 8) Static archives — fast & smart repacking
# -----------------------------------------------------------------------------
# IMPORTANT:
#  - We do NOT create empty .a files. If there are no objects, we do nothing.
#  - By default tests DO NOT touch archives; AUTO_PREP controls priming.
#  - lib-bundles repacks only if missing/empty OR any *.o is newer than the .a.

libcommon_a := $(OUTPUT_PATH)/libcommon.a
libcurl_a   := $(OUTPUT_PATH)/libcurlwrap.a
libssl_a    := $(OUTPUT_PATH)/libsslwrap.a
libtorch_a  := $(OUTPUT_PATH)/libtorchwrap.a

# Optional tracing of the shell body when SHOW_CMD=1
ifeq ($(SHOW_CMD_ON),)
  SH_TRACE :=
else
  SH_TRACE := set -x;
endif

# Smart repack helper: safe when dir missing / empty; prints clear errors on failure

define MAYBE_PACK
	$(Q)$(SH_TRACE) \
	out="$(strip $(1))"; dir="$(strip $(2))"; \
	if [ -d "$$dir" ]; then \
	  objs="$$(find "$$dir" -type f -name '*.o' -print 2>/dev/null)"; \
	  if [ -n "$$objs" ]; then \
	    need=0; \
	    if [ ! -s "$$out" ]; then need=1; \
	    else \
	      for f in $$objs; do \
	        if [ "$$f" -nt "$$out" ]; then need=1; break; fi; \
	      done; \
	    fi; \
	    if [ $$need -eq 1 ]; then \
	      mkdir -p "$$(dirname "$$out")" || { echo "lib-bundles: mkdir failed for $$out" >&2; exit 1; }; \
	      $(AR) rcs "$$out" $$objs       || { echo "lib-bundles: ar failed for $$out"    >&2; exit 1; }; \
	      printf "$(COLOR_DIM_YELLOW)[$(COLOR_GRAY)MODULE:$(COLOR_DIM_GREEN)OK$(COLOR_DIM_YELLOW)]$(COLOR_RESET)  $(COLOR_GREEN)%s$(COLOR_RESET)\n" "$$out"; \
	    fi; \
	  fi; \
	fi; :
endef

# and (optional but recommended) remove the cosmetic alignment spaces:
lib-bundles:
	$(call MAYBE_PACK,$(libcommon_a),$(OUTPUT_PATH)/common)
	$(call MAYBE_PACK,$(libcurl_a),$(OUTPUT_PATH)/libcurl)
	$(call MAYBE_PACK,$(libssl_a),$(OUTPUT_PATH)/openssl)
	$(call MAYBE_PACK,$(libtorch_a),$(OUTPUT_PATH)/libtorch)

# -----------------------------------------------------------------------------
# 9) Sugar Macros for Source Makefiles (producers)
# -----------------------------------------------------------------------------
define BUILD_OBJ
$$(OUTPUT_PATH)/$$(strip $(1))/$$(strip $(2)).o: $$(HERE_PATH)/$$(strip $(2)).cpp
	$$(CC_RULE)

.PHONY: $$(strip $(3))
$$(strip $(3)): $$(OUTPUT_PATH)/$$(strip $(1))/$$(strip $(2)).o
	$$(Q)printf "$(COLOR_DIM_YELLOW)[$(COLOR_GRAY)MODULE:$(COLOR_DIM_GREEN)OK$(COLOR_DIM_YELLOW)]$(COLOR_RESET)  $(COLOR_GREEN)%s/$(notdir $$@)$(COLOR_RESET)\n" "$(REL_MODULE)"
endef

define BUILD_OBJ_INC
$$(OUTPUT_PATH)/$$(strip $(1))/$$(strip $(2)).o: INCLUDES_EXTRA := $$(strip $(4))
$$(eval $$(call BUILD_OBJ,$$(strip $(1)),$$(strip $(2)),$$(strip $(3))))
endef

# -----------------------------------------------------------------------------
# 10) Test Helpers (one-file tests + dispatcher)
# -----------------------------------------------------------------------------
TEST_DEFAULT_LDLIBS ?= $(libcommon_a)

# ---- Fast test toggle ----
# Default: assume impl + archives are already built (no prework).
# Use AUTO_PREP=1 to auto-prime a clean tree once (smart + cheap).
AUTO_PREP ?= 0

ifeq ($(AUTO_PREP),1)
  ORDER_PREP := autoprep lib-bundles
else
  ORDER_PREP :=
endif

# Light auto-prime:
#  - If any archive is missing or empty, build impl/all, then pack as needed.
.PHONY: autoprep
autoprep:
	$(Q)set -e; need=0; \
	for a in $(libcommon_a) $(libtorch_a) $(libcurl_a) $(libssl_a); do \
	  if [ ! -s $$a ]; then need=1; break; fi; \
	done; \
	if [ $$need -eq 1 ]; then \
	  echo "$(COLOR_GRAY)[TEST] priming modules (archives missing/empty)$(COLOR_RESET)"; \
	  $(MAKE) -C $(IMPL_PATH) all; \
	  $(MAKE) lib-bundles; \
	fi

# ------------- TEST_ONEFILE -------------
define TEST_ONEFILE
$(1)_DEPS := $(filter %.a,$(TEST_DEFAULT_LDLIBS) $(3))

# Source MUST be first prerequisite so the compile line is unambiguous.
$$(TEST_OUT)/$$(strip $(1)): $$(HERE_PATH)/$$(strip $(2)) $$($(1)_DEPS) | $$(ORDER_PREP)
	$(Q)mkdir -p $$(@D) $$(DEPDIR) $$(OBJTMP)
	$(Q)$$(LOG_START)
	$(Q)$$(LOCAL_CLEAN)
	# Compile the real source (explicit path avoids $< pitfalls)
	$(Q)$$(CXX) $$(CXXFLAGS) \
	      -MMD -MP -MF $$(DEPDIR)/$$(basename $$(notdir $$@)).d -MT $$@ \
	      $$(USUAL_INCLUDE_PATHS) $$(INCLUDES_EXTRA) \
	      -c $$(HERE_PATH)/$$(strip $(2)) -o $$(OBJTMP)/$$(basename $$(notdir $$@)).o
	# Link
	$(Q)$$(CXX) $$(LDFLAGS) \
	      $$(OBJTMP)/$$(basename $$(notdir $$@)).o \
	      $$(LDLIBS_common) $$(TEST_DEFAULT_LDLIBS) $(3) $$(LDLIBS_EXTRA) \
	      -o $$@
	$(Q)$$(LOG_END)

.PHONY: run-$$(strip $(1))
run-$$(strip $(1)): $$(TEST_OUT)/$$(strip $(1))
	$(Q)$$(RUN_MODE) $$(TEST_OUT)/$$(strip $(1))
endef

# -----------------------------------------------------------------------------
# 11) Dispatcher (build-first, then run)
#   Running `make -C tests test_<name> SHOW_CMD=1` shows g++ commands
#   whenever the test needs to be rebuilt.
#   If build fails (likely missing archives), we print a hint for AUTO_PREP=1.
# -----------------------------------------------------------------------------
define FORWARD_ONE
.PHONY: test_$(1)
test_$(1):
	$(Q)echo "$(COLOR_GRAY)[DISPATCH_TEST]$(COLOR_RESET) $(2)/test_$(1)"
	# If SHOW_CMD=1, force the recipe to run by removing the binary first.
	# Always remove the test binary so it is rebuilt before each run
	$(Q)rm -f '$(TEST_OUT)/test_$(1)' || true
	# Build first (shows compile/link if anything is stale)
	$(Q)+{ \
	  $(MAKE) -C $(2) $(TEST_OUT)/test_$(1) || { \
	    echo "$(COLOR_GRAY)[HINT]$(COLOR_RESET) If this failed due to missing archives, try: AUTO_PREP=1 make -C tests $@"; \
	    exit 1; \
	  }; \
	}
	# Then run (kept separate to avoid hiding build commands)
	$(Q)+$(MAKE) -C $(2) run-test_$(1)
endef
